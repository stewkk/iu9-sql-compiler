% !TeX TXS-program:bibliography = txs:///biber
\documentclass[14pt, russian]{scrartcl}
\let\counterwithout\relax
\let\counterwithin\relax
%\usepackage{lmodern}
\usepackage{float}
\usepackage{xcolor}
\usepackage{extsizes}
\usepackage{subfig}
\usepackage[export]{adjustbox}
\usepackage{tocvsec2} % возможность менять учитываемую глубину разделов в оглавлении
\usepackage[subfigure]{tocloft}
\usepackage[newfloat]{minted}
\captionsetup[listing]{position=top}

\AtBeginEnvironment{figure}{\vspace{0.5cm}}
\AtBeginEnvironment{table}{\vspace{0.5cm}}
\AtBeginEnvironment{listing}{\vspace{0.5cm}}
\AtBeginEnvironment{algorithm}{\vspace{0.5cm}}
\AtBeginEnvironment{minted}{\vspace{-0.5cm}}

\usepackage{fancyvrb}
\usepackage{ulem,bm,mathrsfs,ifsym} %зачеркивания, особо жирный стиль и RSFS начертание
\usepackage{sectsty} % переопределение стилей подразделов
%%%%%%%%%%%%%%%%%%%%%%%

%%% Поля и разметка страницы %%%
\usepackage{pdflscape}                              % Для включения альбомных страниц
\usepackage{geometry}                               % Для последующего задания полей
\geometry{a4paper,tmargin=2cm,bmargin=2cm,lmargin=3cm,rmargin=1cm} % тоже самое, но лучше

%%% Математические пакеты %%%
\usepackage{amsthm,amsfonts,amsmath,amssymb,amscd}  % Математические дополнения от AMS
\usepackage{mathtools}                              % Добавляет окружение multlined
\usepackage[perpage]{footmisc}
%\usepackage{times}

\def\ojoin{\setbox0=\hbox{$\bowtie$}%
  \rule[-.02ex]{.25em}{.4pt}\llap{\rule[\ht0]{.25em}{.4pt}}}
\def\leftouterjoin{\mathbin{\ojoin\mkern-5.8mu\bowtie}}
\def\rightouterjoin{\mathbin{\bowtie\mkern-5.8mu\ojoin}}
\def\fullouterjoin{\mathbin{\ojoin\mkern-5.8mu\bowtie\mkern-5.8mu\ojoin}}

%%%% Установки для размера шрифта 14 pt %%%%
%% Формирование переменных и констант для сравнения (один раз для всех подключаемых файлов)%%
%% должно располагаться до вызова пакета fontspec или polyglossia, потому что они сбивают его работу
%\newlength{\curtextsize}
%\newlength{\bigtextsize}
%\setlength{\bigtextsize}{13pt}
\KOMAoptions{fontsize=14pt}

\makeatletter
\def\showfontsize{\f@size{} point}
\makeatother

%\makeatletter
%\show\f@size                                       % неплохо для отслеживания, но вызывает стопорение процесса, если документ компилируется без команды  -interaction=nonstopmode
%\setlength{\curtextsize}{\f@size pt}
%\makeatother

%шрифт times
\usepackage{tempora}
%\usepackage{pscyr}
%\setmainfont[Ligatures={TeX,Historic}]{Times New Roman}

   %%% Решение проблемы копирования текста в буфер кракозябрами
%    \input glyphtounicode.tex
%    \input glyphtounicode-cmr.tex %from pdfx package
%    \pdfgentounicode=1
    \usepackage{cmap}                               % Улучшенный поиск русских слов в полученном pdf-файле
    \usepackage[T1]{fontenc}                       % Поддержка русских букв
    \usepackage[utf8]{inputenc}                     % Кодировка utf8
    \usepackage[english, main=russian]{babel}            % Языки: русский, английский
%   \IfFileExists{pscyr.sty}{\usepackage{pscyr}}{}  % Красивые русские шрифты
%\renewcommand{\rmdefault}{ftm}
%%% Оформление абзацев %%%
\usepackage{indentfirst}                            % Красная строка
%\usepackage{eskdpz}

%%% Таблицы %%%
\usepackage{longtable}                              % Длинные таблицы
\usepackage{multirow,makecell,array}                % Улучшенное форматирование таблиц
\usepackage{booktabs}                               % Возможность оформления таблиц в классическом книжном стиле (при правильном использовании не противоречит ГОСТ)

%%% Общее форматирование
\usepackage{soulutf8}                               % Поддержка переносоустойчивых подчёркиваний и зачёркиваний
\usepackage{icomma}                                 % Запятая в десятичных дробях



%%% Изображения %%%
\usepackage{graphicx}                               % Подключаем пакет работы с графикой
\usepackage{wrapfig}

\usepackage{tikz}
\usetikzlibrary{shapes.misc}
\usetikzlibrary{trees}

%%% Списки %%%
\usepackage{enumitem}

%%% Подписи %%%
\usepackage{caption}                                % Для управления подписями (рисунков и таблиц) % Может управлять номерами рисунков и таблиц с caption %Иногда может управлять заголовками в списках рисунков и таблиц
%% Использование:
%\begin{table}[h!]\ContinuedFloat - чтобы не переключать счетчик
%\captionsetup{labelformat=continued}% должен стоять до самого caption
%\caption{}
% либо ручками \caption*{Продолжение таблицы~\ref{...}.} :)

%%% Интервалы %%%
\addto\captionsrussian{%
  \renewcommand{\listingname}{Листинг}%
}
%%% Счётчики %%%
\usepackage[figure,table,section]{totalcount}               % Счётчик рисунков и таблиц
\DeclareTotalCounter{lstlisting}
\usepackage{totcount}                               % Пакет создания счётчиков на основе последнего номера подсчитываемого элемента (может требовать дважды компилировать документ)
\usepackage{totpages}                               % Счётчик страниц, совместимый с hyperref (ссылается на номер последней страницы). Желательно ставить последним пакетом в преамбуле

%%% Продвинутое управление групповыми ссылками (пока только формулами) %%%
%% Кодировки и шрифты %%%

%   \newfontfamily{\cyrillicfont}{Times New Roman}
%   \newfontfamily{\cyrillicfonttt}{CMU Typewriter Text}
	%\setmainfont{Times New Roman}
	%\newfontfamily\cyrillicfont{Times New Roman}
	%\setsansfont{Times New Roman}                    %% задаёт шрифт без засечек
%	\setmonofont{Liberation Mono}               %% задаёт моноширинный шрифт
%    \IfFileExists{pscyr.sty}{\renewcommand{\rmdefault}{ftm}}{}
%%% Интервалы %%%
%linespread-реализация ближе к реализации полуторного интервала в ворде.
%setspace реализация заточена под шрифты 10, 11, 12pt, под остальные кегли хуже, но всё же ближе к типографской классике.
\linespread{1.3}                    % Полуторный интервал (ГОСТ Р 7.0.11-2011, 5.3.6)
%\renewcommand{\@biblabel}[1]{#1}

%%% Гиперссылки %%%
\usepackage{hyperref}

%%% Выравнивание и переносы %%%
\sloppy                             % Избавляемся от переполнений
\clubpenalty=10000                  % Запрещаем разрыв страницы после первой строки абзаца
\widowpenalty=10000                 % Запрещаем разрыв страницы после последней строки абзаца

\makeatletter % малые заглавные, small caps shape
\let\@@scshape=\scshape
\renewcommand{\scshape}{%
  \ifnum\strcmp{\f@series}{bx}=\z@
    \usefont{T1}{cmr}{bx}{sc}%
  \else
    \ifnum\strcmp{\f@shape}{it}=\z@
      \fontshape{scsl}\selectfont
    \else
      \@@scshape
    \fi
  \fi}
\makeatother

%%% Подписи %%%
%\captionsetup{%
%singlelinecheck=off,                % Многострочные подписи, например у таблиц
%skip=2pt,                           % Вертикальная отбивка между подписью и содержимым рисунка или таблицы определяется ключом
%justification=centering,            % Центрирование подписей, заданных командой \caption
%}
%%%        Подключение пакетов                 %%%
\usepackage{ifthen}                 % добавляет ifthenelse
%%% Инициализирование переменных, не трогать!  %%%
\newcounter{intvl}
\newcounter{otstup}
\newcounter{contnumeq}
\newcounter{contnumfig}
\newcounter{contnumtab}
\newcounter{pgnum}
\newcounter{bibliosel}
\newcounter{chapstyle}
\newcounter{headingdelim}
\newcounter{headingalign}
\newcounter{headingsize}
\newcounter{tabcap}
\newcounter{tablaba}
\newcounter{tabtita}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%% Область упрощённого управления оформлением %%%

%% Интервал между заголовками и между заголовком и текстом
% Заголовки отделяют от текста сверху и снизу тремя интервалами (ГОСТ Р 7.0.11-2011, 5.3.5)
\setcounter{intvl}{3}               % Коэффициент кратности к размеру шрифта

%% Отступы у заголовков в тексте
\setcounter{otstup}{0}              % 0 --- без отступа; 1 --- абзацный отступ

%% Нумерация формул, таблиц и рисунков
\setcounter{contnumeq}{1}           % Нумерация формул: 0 --- пораздельно (во введении подряд, без номера раздела); 1 --- сквозная нумерация по всей диссертации
\setcounter{contnumfig}{1}          % Нумерация рисунков: 0 --- пораздельно (во введении подряд, без номера раздела); 1 --- сквозная нумерация по всей диссертации
\setcounter{contnumtab}{1}          % Нумерация таблиц: 0 --- пораздельно (во введении подряд, без номера раздела); 1 --- сквозная нумерация по всей диссертации

%% Оглавление
\setcounter{pgnum}{0}               % 0 --- номера страниц никак не обозначены; 1 --- Стр. над номерами страниц (дважды компилировать после изменения)

%% Библиография
\setcounter{bibliosel}{1}           % 0 --- встроенная реализация с загрузкой файла через движок bibtex8; 1 --- реализация пакетом biblatex через движок biber

%% Текст и форматирование заголовков
\setcounter{chapstyle}{1}           % 0 --- разделы только под номером; 1 --- разделы с названием "Глава" перед номером
\setcounter{headingdelim}{1}        % 0 --- номер отделен пропуском в 1em или \quad; 1 --- номера разделов и приложений отделены точкой с пробелом, подразделы пропуском без точки; 2 --- номера разделов, подразделов и приложений отделены точкой с пробелом.

%% Выравнивание заголовков в тексте
\setcounter{headingalign}{0}        % 0 --- по центру; 1 --- по левому краю

%% Размеры заголовков в тексте
\setcounter{headingsize}{0}         % 0 --- по ГОСТ, все всегда 14 пт; 1 --- пропорционально изменяющийся размер в зависимости от базового шрифта

%% Подпись таблиц
\setcounter{tabcap}{0}              % 0 --- по ГОСТ, номер таблицы и название разделены тире, выровнены по левому краю, при необходимости на нескольких строках; 1 --- подпись таблицы не по ГОСТ, на двух и более строках, дальнейшие настройки:
%Выравнивание первой строки, с подписью и номером
\setcounter{tablaba}{2}             % 0 --- по левому краю; 1 --- по центру; 2 --- по правому краю
%Выравнивание строк с самим названием таблицы
\setcounter{tabtita}{1}             % 0 --- по левому краю; 1 --- по центру; 2 --- по правому краю

%%% Рисунки %%%
\DeclareCaptionLabelSeparator*{emdash}{~--- }             % (ГОСТ 2.105, 4.3.1)
\captionsetup[figure]{labelsep=emdash,font=onehalfspacing,position=bottom}

%%% Таблицы %%%
\ifthenelse{\equal{\thetabcap}{0}}{%
    \newcommand{\tabcapalign}{\raggedright}  % по левому краю страницы или аналога parbox
}

\ifthenelse{\equal{\thetablaba}{0} \AND \equal{\thetabcap}{1}}{%
    \newcommand{\tabcapalign}{\raggedright}  % по левому краю страницы или аналога parbox
}

\ifthenelse{\equal{\thetablaba}{1} \AND \equal{\thetabcap}{1}}{%
    \newcommand{\tabcapalign}{\centering}    % по центру страницы или аналога parbox
}

\ifthenelse{\equal{\thetablaba}{2} \AND \equal{\thetabcap}{1}}{%
    \newcommand{\tabcapalign}{\raggedleft}   % по правому краю страницы или аналога parbox
}

\ifthenelse{\equal{\thetabtita}{0} \AND \equal{\thetabcap}{1}}{%
    \newcommand{\tabtitalign}{\raggedright}  % по левому краю страницы или аналога parbox
}

\ifthenelse{\equal{\thetabtita}{1} \AND \equal{\thetabcap}{1}}{%
    \newcommand{\tabtitalign}{\centering}    % по центру страницы или аналога parbox
}

\ifthenelse{\equal{\thetabtita}{2} \AND \equal{\thetabcap}{1}}{%
    \newcommand{\tabtitalign}{\raggedleft}   % по правому краю страницы или аналога parbox
}

\DeclareCaptionFormat{tablenocaption}{\tabcapalign #1\strut}        % Наименование таблицы отсутствует
\ifthenelse{\equal{\thetabcap}{0}}{%
    \DeclareCaptionFormat{tablecaption}{\tabcapalign #1#2#3}
    \captionsetup[table]{labelsep=emdash}                       % тире как разделитель идентификатора с номером от наименования
}{%
    \DeclareCaptionFormat{tablecaption}{\tabcapalign #1#2\par%  % Идентификатор таблицы на отдельной строке
        \tabtitalign{#3}}                                       % Наименование таблицы строкой ниже
    \captionsetup[table]{labelsep=space}                        % пробельный разделитель идентификатора с номером от наименования
}
\captionsetup[table]{format=tablecaption,singlelinecheck=off,font=onehalfspacing,position=top,skip=-5pt}  % многострочные наименования и прочее
\DeclareCaptionLabelFormat{continued}{Продолжение таблицы~#2}
\setlength{\belowcaptionskip}{.2cm}
\setlength{\intextsep}{0ex}

%%% Подписи подрисунков %%%
\renewcommand{\thesubfigure}{\asbuk{subfigure}}           % Буквенные номера подрисунков
\captionsetup[subfigure]{font={normalsize},               % Шрифт подписи названий подрисунков (не отличается от основного)
    labelformat=brace,                                    % Формат обозначения подрисунка
    justification=centering,                              % Выключка подписей (форматирование), один из вариантов
}
%\DeclareCaptionFont{font12pt}{\fontsize{12pt}{13pt}\selectfont} % объявляем шрифт 12pt для использования в подписях, тут же надо интерлиньяж объявлять, если не наследуется
%\captionsetup[subfigure]{font={font12pt}}                 % Шрифт подписи названий подрисунков (всегда 12pt)

%%% Настройки гиперссылок %%%

\definecolor{linkcolor}{rgb}{0.0,0,0}
\definecolor{citecolor}{rgb}{0,0.0,0}
\definecolor{urlcolor}{rgb}{0,0,0}

\hypersetup{
    linktocpage=true,           % ссылки с номера страницы в оглавлении, списке таблиц и списке рисунков
%    linktoc=all,                % both the section and page part are links
%    pdfpagelabels=false,        % set PDF page labels (true|false)
    plainpages=true,           % Forces page anchors to be named by the Arabic form  of the page number, rather than the formatted form
    colorlinks,                 % ссылки отображаются раскрашенным текстом, а не раскрашенным прямоугольником, вокруг текста
    linkcolor={linkcolor},      % цвет ссылок типа ref, eqref и подобных
    citecolor={citecolor},      % цвет ссылок-цитат
    urlcolor={urlcolor},        % цвет гиперссылок
    pdflang={ru},
}
\urlstyle{same}
%%% Шаблон %%%
%\DeclareRobustCommand{\todo}{\textcolor{red}}       % решаем проблему превращения названия цвета в результате \MakeUppercase, http://tex.stackexchange.com/a/187930/79756 , \DeclareRobustCommand protects \todo from expanding inside \MakeUppercase
\setlength{\parindent}{2.5em}                       % Абзацный отступ. Должен быть одинаковым по всему тексту и равен пяти знакам (ГОСТ Р 7.0.11-2011, 5.3.7).

%%% Списки %%%
% Используем дефис для ненумерованных списков (ГОСТ 2.105-95, 4.1.7)
%\renewcommand{\labelitemi}{\normalfont\bfseries~{---}}
\renewcommand{\labelitemi}{\bfseries~{---}}
\setlist{nosep,%                                    % Единый стиль для всех списков (пакет enumitem), без дополнительных интервалов.
    labelindent=\parindent,leftmargin=*%            % Каждый пункт, подпункт и перечисление записывают с абзацного отступа (ГОСТ 2.105-95, 4.1.8)
}
%%%%%%%%%%%%%%%%%%%%%%
%\usepackage{xltxtra} % load xunicode

\usepackage{ragged2e}
\usepackage[explicit]{titlesec}
\usepackage{placeins}
\usepackage{xparse}
\usepackage{csquotes}

\usepackage{listingsutf8}
\usepackage{url} %пакеты расширений
\usepackage{algorithm, algorithmicx}
\usepackage[noend]{algpseudocode}
\usepackage{blkarray}
\usepackage{chngcntr}
\usepackage{tabularx}
\usepackage[backend=biber,
    bibstyle=gost-numeric,
    citestyle=nature]{biblatex}
\newcommand*\template[1]{\text{<}#1\text{>}}
\addbibresource{biblio.bib}

\titleformat{name=\section,numberless}[block]{\normalfont\Large\centering}{}{0em}{#1}
\titleformat{\section}[block]{\normalfont\Large\bfseries\raggedright}{}{0em}{\thesection\hspace{0.25em}#1}
\titleformat{\subsection}[block]{\normalfont\Large\bfseries\raggedright}{}{0em}{\thesubsection\hspace{0.25em}#1}
\titleformat{\subsubsection}[block]{\normalfont\large\bfseries\raggedright}{}{0em}{\thesubsubsection\hspace{0.25em}#1}

\let\Algorithm\algorithm
\renewcommand\algorithm[1][]{\Algorithm[#1]\setstretch{1.5}}
%\renewcommand{\listingscaption}{Листинг}

\usepackage{pifont}
\usepackage{calc}
\usepackage{suffix}
\usepackage{csquotes}
\DeclareQuoteStyle{russian}
    {\guillemotleft}{\guillemotright}[0.025em]
    {\quotedblbase}{\textquotedblleft}
\ExecuteQuoteOptions{style=russian}
\newcommand{\enq}[1]{\enquote{#1}}
\newcommand{\eng}[1]{\begin{english}#1\end{english}}
% Подчиненные счетчики в окружениях http://old.kpfu.ru/journals/izv_vuz/arch/sample1251.tex
\newcounter{cTheorem}
\newcounter{cDefinition}
\newcounter{cConsequent}
\newcounter{cExample}
\newcounter{cLemma}
\newcounter{cConjecture}
\newtheorem{Theorem}{Теорема}[cTheorem]
\newtheorem{Definition}{Определение}[cDefinition]
\newtheorem{Consequent}{Следствие}[cConsequent]
\newtheorem{Example}{Пример}[cExample]
\newtheorem{Lemma}{Лемма}[cLemma]
\newtheorem{Conjecture}{Гипотеза}[cConjecture]

\renewcommand{\theTheorem}{\arabic{Theorem}}
\renewcommand{\theDefinition}{\arabic{Definition}}
\renewcommand{\theConsequent}{\arabic{Consequent}}
\renewcommand{\theExample}{\arabic{Example}}
\renewcommand{\theLemma}{\arabic{Lemma}}
\renewcommand{\theConjecture}{\arabic{Conjecture}}
%\makeatletter
\NewDocumentCommand{\Newline}{}{\text{\\}}
\newcommand{\sequence}[2]{\ensuremath \left(#1,\ \dots,\ #2\right)}

\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}
\renewcommand{\listalgorithmname}{Список алгоритмов}
\floatname{algorithm}{Листинг}
\renewcommand{\lstlistingname}{Листинг}
\renewcommand{\thealgorithm}{\arabic{algorithm}}

\newcommand{\refAlgo}[1]{(листинг~\ref{#1})}
\newcommand{\refImage}[1]{(рисунок~\ref{#1})}

\renewcommand{\theenumi}{\arabic{enumi}.}% Меняем везде перечисления на цифра.цифра
\renewcommand{\labelenumi}{\arabic{enumi}.}% Меняем везде перечисления на цифра.цифра
\renewcommand{\theenumii}{\arabic{enumii}}% Меняем везде перечисления на цифра.цифра
\renewcommand{\labelenumii}{(\arabic{enumii})}% Меняем везде перечисления на цифра.цифра
\renewcommand{\theenumiii}{\roman{enumiii}}% Меняем везде перечисления на цифра.цифра
\renewcommand{\labelenumiii}{(\roman{enumiii})}% Меняем везде перечисления на цифра.цифра
%\newfontfamily\AnkaCoder[Path=src/fonts/]{AnkaCoder-r.ttf}
\renewcommand{\labelitemi}{---}
\renewcommand{\labelitemii}{---}

%\usepackage{courier}

\lstdefinelanguage{Refal}{
  alsodigit = {.,<,>},
  morekeywords = [1]{$ENTRY},
  morekeywords = [2]{Go, Put, Get, Open, Close, Arg, Add, Sub, Mul, Div, Symb, Explode, Implode},
  %keyword4
  morekeywords = [3]{<,>},
  %keyword5
  morekeywords = [4]{e.,t.,s.},
  sensitive = true,
  morecomment = [l]{*},
  morecomment = [s]{/*}{*/},
  commentstyle = \color{mygreen},
  morestring = [b]",
  morestring = [b]',
  stringstyle = \color{purple}
}

\makeatletter
\def\p@subsection{}
\def\p@subsubsection{\thesection\,\thesubsection\,}
\makeatother
\newcommand{\prog}[1]{{\ttfamily\small#1}}
\lstset{ %
  backgroundcolor=\color{white},   % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}
  basicstyle=\ttfamily\footnotesize,
  %basicstyle=\footnotesize\AnkaCoder,        % the size of the fonts that are used for the code
  breakatwhitespace=false,         % sets if automatic breaks shoulbd only happen at whitespace
  breaklines=true,                 % sets automatic line breaking
  captionpos=top,                    % sets the caption-position to bottom
  commentstyle=\color{mygreen},    % comment style
  deletekeywords={...},            % if you want to delete keywords from the given language
  escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
  extendedchars=true,              % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
  inputencoding=utf8,
  frame=single,                    % adds a frame around the code
  keepspaces=true,                 % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
  keywordstyle=\bf,       % keyword style
  language=Refal,                    % the language of the code
  morekeywords={<,>,$ENTRY,Go,Arg, Open, Close, e., s., t., Get, Put},
  							       % if you want to add more keywords to the set
  numbers=left,                    % where to put the line-numbers; possible values are (none, left, right)
  numbersep=5pt,                   % how far the line-numbers are from the code
  xleftmargin=25pt,
  xrightmargin=25pt,
  numberstyle=\small\color{black}, % the style that is used for the line-numbers
  rulecolor=\color{black},         % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
  showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
  showstringspaces=false,          % underline spaces within strings only
  showtabs=false,                  % show tabs within strings adding particular underscores
  stepnumber=1,                    % the step between two line-numbers. If it's 1, each line will be numbered
  stringstyle=\color{mymauve},     % string literal style
  tabsize=8,                       % sets default tabsize to 8 spaces
  title=\lstname                   % show the filename of files included with \lstinputlisting; also try caption instead of title
}
\newcommand{\anonsection}[1]{\cleardoublepage
\phantomsection
\addcontentsline{toc}{section}{\protect\numberline{}#1}
\section*{#1}\vspace*{2.5ex} % По госту положены 3 пустые строки после заголовка ненумеруемого раздела
}
\newcommand{\sectionbreak}{\clearpage}
\renewcommand{\sectionfont}{\normalsize} % Сбиваем стиль оглавления в стандартный
\renewcommand{\cftsecleader}{\cftdotfill{\cftdotsep}} % Точки в оглавлении напротив разделов

\renewcommand{\cftsecfont}{\normalfont\large} % Переключение на times в содержании
\renewcommand{\cftsubsecfont}{\normalfont\large} % Переключение на times в содержании

\usepackage{caption}
%\captionsetup[table]{justification=raggedleft}
%\captionsetup[figure]{justification=centering,labelsep=endash}
\usepackage{amsmath}    % \bar    (матрицы и проч. ...)
\usepackage{amsfonts}   % \mathbb (символ для множества действительных чисел и проч. ...)
\usepackage{mathtools}  % \abs, \norm
    \DeclarePairedDelimiter\abs{\lvert}{\rvert} % операция модуля
    \DeclarePairedDelimiter\norm{\lVert}{\rVert} % операция нормы
\DeclareTextCommandDefault{\textvisiblespace}{%
  \mbox{\kern.06em\vrule \@height.3ex}%
  \vbox{\hrule \@width.3em}%
  \hbox{\vrule \@height.3ex}}
\newsavebox{\spacebox}
\begin{lrbox}{\spacebox}
\verb*! !
\end{lrbox}
\newcommand{\aspace}{\usebox{\spacebox}}
\DeclareTotalCounter{listing}

\makeatletter
\renewcommand*{\p@subsubsection}{}
\makeatother

\makeatletter
\AddToHook{begindocument/before}{\@ifpackageloaded{minted}{\removefromtoclist[float]{lol}}{}}
\makeatother

\begin{document}
\sloppy

\def\figurename{Рисунок}

\begin{titlepage}
	\thispagestyle{empty}
	\newpage

	\vspace*{-30pt}
	\hspace{-45pt}
	\begin{minipage}{0.17\textwidth}
		\hspace*{-20pt}\centering
		\includegraphics[width=1.3\textwidth]{emblem.png}
	\end{minipage}
	\begin{minipage}{0.82\textwidth}\small \textbf{
			\vspace*{-0.7ex}
			\hspace*{-10pt}\centerline{Министерство науки и высшего образования Российской Федерации}
			\vspace*{-0.7ex}
			\centerline{Федеральное государственное автономное образовательное учреждение }
			\vspace*{-0.7ex}
			\centerline{высшего образования}
			\vspace*{-0.7ex}
			\centerline{<<Московский государственный технический университет}
			\vspace*{-0.7ex}
			\centerline{имени Н.Э. Баумана}
			\vspace*{-0.7ex}
			\centerline{(национальный исследовательский университет)>>}
			\vspace*{-0.7ex}
			\centerline{(МГТУ им. Н.Э. Баумана)}}
	\end{minipage}

	\vspace{-2pt}
	\hspace{-34.5pt}\rule{\textwidth}{2.5pt}

	\vspace*{-20.3pt}
	\hspace{-34.5pt}\rule{\textwidth}{0.4pt}

	\vspace{0.5ex}
	\noindent \small ФАКУЛЬТЕТ\hspace{80pt} <<Информатика и системы управления>>

	\vspace*{-16pt}
	\hspace{35pt}\rule{0.855\textwidth}{0.4pt}

	\vspace{0.5ex}
	\noindent \small КАФЕДРА\hspace{50pt} <<Теоретическая информатика и компьютерные технологии>>

	\vspace*{-16pt}
	\hspace{25pt}\rule{0.875\textwidth}{0.4pt}


	\vspace{3em}

	\begin{center}
		\Large \bf{РАСЧЕТНО-ПОЯСНИТЕЛЬНАЯ ЗАПИСКА\\\textbf{\textit{К КУРСОВОЙ РАБОТЕ\\НА ТЕМУ:}} \\}
	\end{center}

	\vspace*{-6ex}
	\begin{center}
		\Large{\textit{\textbf{<<Оптимизирующий компилятор запросов }}}

		\vspace*{-3ex}
		\rule{0.9\textwidth}{1.2pt}

		\vspace*{-0.2ex}
		\Large{\textit{\textbf{подмножества SQL на основе LLVM>>}}}

		\vspace*{-3ex}
		\vspace*{-0.2ex}
		\rule{0.9\textwidth}{1.2pt}

		\vspace*{-0.2ex}
		\rule{0.9\textwidth}{1.2pt}

		\vspace*{-0.2ex}
		\rule{0.9\textwidth}{1.2pt}

		\vspace*{-0.2ex}
		\rule{0.9\textwidth}{1.2pt}
	\end{center}

	\vspace{\fill}


	\newlength{\ML}
	\settowidth{\ML}{«\underline{\hspace{0.7cm}}» \underline{\hspace{2cm}}}

	\noindent Студент \underline{\text{ИУ9-71Б}} \hfill \underline{ \hspace{4cm}}\quad
	\raisebox{0.45ex}{\underline{\parbox{4cm}{\centering Старовойтов А.И.}}}

	\vspace{-2.1ex}
	\noindent\hspace{9ex}\scriptsize{(Группа)}\normalsize\hspace{170pt}\hspace{2ex}\scriptsize{(Подпись, дата)}\normalsize\hspace{30pt}\hspace{6ex}\scriptsize{(И.О. Фамилия)}\normalsize

	\bigskip

	\noindent Руководитель  \hfill \underline{\hspace{4cm}}\quad
	\raisebox{0.35ex}{\underline{\parbox{4cm}{\centering Непейвода А.Н.}}}

	\vspace{-2ex}
	\noindent\hspace{13.5ex}\normalsize\hspace{170pt}\hspace{2ex}\scriptsize{(Подпись, дата)}\normalsize\hspace{30pt}\hspace{6ex}\scriptsize{(И.О. Фамилия)}\normalsize

	\bigskip

	\noindent Консультант\hfill \underline{\hspace{4cm}}\quad
	\underline{\hspace{4cm}}

	\vspace{-2ex}
	\noindent\hspace{13.5ex}\normalsize\hspace{170pt}\hspace{2ex}\scriptsize{(Подпись, дата)}\normalsize\hspace{30pt}\hspace{6ex}\scriptsize{(И.О. Фамилия)}\normalsize
	\vfill

	%\vspace{\fill}



	\begin{center}
		\textsl{2026 г.}
	\end{center}
\end{titlepage}

%\renewcommand{\ttdefault}{pcr}

\setlength{\tabcolsep}{3pt}
\newpage
\setcounter{page}{2}
%----------------------------------------------------------------------------
%                  ОТСЮДА --- СОБСТВЕННО ТЕКСТ
%----------------------------------------------------------------------------

\newpage
\renewcommand\contentsname{\hfill{\normalfont{СОДЕРЖАНИЕ}}\hfill}  %Оглавление
\tableofcontents
\newpage
\anonsection{ВВЕДЕНИЕ}  %Введение

С развитием технологий обработки больших данных и появлением все большего числа
распределенных высоконагруженных систем, как никогда актуальным становится
вопрос эффективного хранения данных. Системы управления базами данных решают эти
задачи, упрощая разработку и экономя вычислительные ресурсы, а также место на
дисках.

Реляционные системы управления базами данных занимают более половины
рынка~\cite{DBReport} и остаются стандартом для хранения данных. Основным языком
запросов к таким системам является SQL.

Разработчики СУБД постоянно борются за производительность исполнения SQL
запросов, применяя различные техники, например: машинное обучение, аппаратное
ускорение, векторизированное исполнение и т.д. Одним из способов оптимизации,
позволяющим сэкономить ресурсы процессора при выполнении сложных запросов, может
быть JIT-компиляция некоторых частей запроса. Такая техника реализована в самых
популярных СУБД, таких как PostgreSQL~\cite{pantilimonov2019machine} и является
довольно актуальной для автоматически сгенерированных запросов, например в
системах визуализации данных в виде графиков и диаграмм, ввиду сложности
выражений для фильтрации и их неоптимальности.

Целью данной работы является реализация модельной реляционной СУБД с поддержкой
опциональной JIT-компиляции выражений в SELECT запросах на основе LLVM-JIT, а
также сравнение производительности исполнения с компиляцией и без.

\section{Обзор предметной области}

Обычно, СУБД верхнеуровнево разделяют на следующие
модули~\cite{silberschatz2020database}~\refImage{fig:dbms-scheme}:

\begin{itemize}
  \item модуль хранения данных;
  \item модуль обработки запросов;
  \item модуль управления транзакциями.
\end{itemize}

\begin{figure}[H]
  \centering
  \begin{minipage}[t]{\textwidth}
    \centering
    \includegraphics[width=\textwidth]{dbms_scheme}
  \end{minipage}
  \caption{Схема верхнеуровнего устройства СУБД.}\label{fig:dbms-scheme}
\end{figure}

\subsection{Модуль хранения данных}

Модуль хранения данных реализует удобный интерфейс для физического хранения
данных на диске, предоставляя возможность сохранять, читать и обновлять
информацию в базе данных.

Подсистемами модуля хранения данных являются:

\begin{itemize}
  \item система авторизации;
  \item система управления файлами;
  \item система страничной организации памяти.
\end{itemize}

Данные на диске хранятся в нескольких формах: файлы с даннми, хранилище
метаданных и индексы.

\subsection{Модуль обработки запросов}

Модуль обработки запросов отвечает за исполнение запросов пользователя. Его подсистемами являются:

\begin{itemize}
  \item парсер запросов в синтаксическое дерево;
  \item модуль преобразования синтаксического дерева в план исполнения запроса;
  \item оптимизатор планов исполнения запросов;
  \item модуль исполнения плана.
\end{itemize}

\subsection{Модуль управления транзакциями}

Задача этого модуля --- обеспечить атомарное выполнение нескольких запросов,
чтобы сохранить определенные инварианты относительно хранимых данных. Его подсистемами могут являться:

\begin{itemize}
  \item система восстановления после перезапуска;
  \item система синхронизации.
\end{itemize}

\subsection{Реляционная модель и реляционная алгебра}

Реляционная модель объединяет несколько концептов:

\begin{itemize}
  \item \emph{структура}: определения отношений и их содержимого не зависит от
        физического представления. Каждое отношение --- множество атрибутов,
        каждый атрибут имеет множество значений;
  \item \emph{целостность}: соблюдение определенных инвариантов относительно
        хранимых данных;
  \item \emph{интерфейс}: декларативный интерфейс для доступа и изменения данных
        при помощи отношений. Разработчик задает только желаемый результат, а
        СУБД определяет наиболее оптимальный способ его достижения.
\end{itemize}

Все это образует фреймворк для работы с данными, который не отличается от одной
СУБД к другой и избавляет от заботы о низкоуровневых деталях хранения.

\begin{Definition}[Отношение]
  Неупорядоченное множество, элементами которого являются кортежи из значений
  атрибутов, задающих сущности. Отношения иногда называют таблицами.
\end{Definition}

\begin{Definition}[Кортеж]
  Множество значений атрибутов в отношении. Значениями могут быть скаляры или
  более сложные структуры данных. Каждый атрибут, если не задано специальное
  ограничение, может принимать значение \verb|NULL|, означающее, что для данного
  кортежа значение данного атрибута не определено.
\end{Definition}

\begin{Definition}[Реляционная алгебра]
  Множество фундаментальных оперторов для получения и изменения кортежей в
  отношении. Каждый оператор принимает одно или несколько отношений в качестве
  входа и возвращает новое отношение в качестве выхода.
\end{Definition}

Чтобы представлить SQL запрос в терминах реляционной алгебры можно
скомбинировать соответствующие операторы. Перечислим основные:

\begin{itemize}
  \item $\sigma_{\text{predicate}}(R)$ --- позволяет фильтровать кортежи по
        предикату;
  \item $\pi_{A_{1}, \ldots, A\_{n}}(R)$ --- позволяет выбрать нужные атрибуты
        из кортежа;
  \item $\cap, \cup, -$ --- стандартные операции над множествами;
  \item $\times$ --- декартово произведение, соответствует \verb|INNER JOIN|;
  \item $\leftouterjoin, \rightouterjoin, \fullouterjoin$ --- реализуют
        \verb|OUTER JOIN|.
\end{itemize}

\subsection{Язык SQL}

С помощью языка запросов SQL, ``Structured Query Language'', происходит все
взаимодействие клиентов с СУБД: определение схем данных, изменение содержимого
таблиц и т.п. Этот язык появился в начале 1970-х и продолжает развиваться по сей
день. Язык разделяют на две части:

\begin{itemize}
  \item ``Data-definition language'' --- язык для определения схем таблиц;
  \item ``Data-manipulation language'' --- язык для получения и изменения данных в таблицах.
\end{itemize}

В этой работе мы фокусируемся на DML, а именно на части для получения данных,
где наиболее актуальна JIT-компиляция. Этот функционал реализован с помощью
ключевого слова ``SELECT''.

Грамматика ``SELECT''~\refAlgo{lst:select_grammar} позволяет задать:

\begin{itemize}
  \item ``FROM'' --- из каких таблиц брать данные;
  \item ``WHERE'' --- как их отфильтровать;
  \item ``GROUP BY'' --- какие функции агрегации использовать;
  \item ``ORDER BY'' --- порядок сортировки;
  \item ``LIMIT'' --- ограничение на количество кортежей;
  \item ``select\_list'' --- какие атрибуты возвращать.
\end{itemize}

\begin{listing}
  \caption{Грамматика ``SELECT''~\cite{PostgresDocs}.}
  \label{lst:select_grammar}
  \begin{minted}[style=bw, breaklines, frame=single, fontsize = \footnotesize, linenos=false, xleftmargin = 1.5em]{text}
SELECT [ DISTINCT | ALL ] select_list
    [ FROM table_expression ]
    [ WHERE condition ]
    [ GROUP BY grouping_element [, ...] ]
    [ HAVING condition ]
    [ WINDOW window_name AS ( window_definition ) [, ...] ]
    [ ORDER BY sort_expression [ ASC | DESC | USING operator ] [, ...] ]
    [ LIMIT { count | ALL } ]
    [ OFFSET start [ ROW | ROWS ] ]
    [ FETCH { FIRST | NEXT } [ count ] { ROW | ROWS } ONLY ]
    [ FOR { UPDATE | SHARE } [ OF table_name [, ...] ] [ NOWAIT | SKIP LOCKED ] [, ...] ] ;
  \end{minted}
\end{listing}

Пример ``SELECT'' запроса представлен в листинге~\ref{lst:select_example}.

\begin{listing}
  \caption{Пример SQL запроса.}
  \label{lst:select_example}
  \begin{minted}[style=bw, breaklines, frame=single, fontsize = \footnotesize, linenos=false, xleftmargin = 1.5em]{SQL}
SELECT name, phone FROM users WHERE age > 22;
  \end{minted}
\end{listing}

\subsection{Парсинг SQL запросов}

Парсер отвечает за преобразование SQL-запросов в абстрактное синтаксическое
дерево.

Помимо ANSI стандартов язка практически каждая СУБД реализует свой набор
расширений. Самым популярным из них считается синтаксис ``PostgreSQL''.

Синтаксис SQL довольно объемный, поэтому обычно используют генераторы
лексических и синтаксических анализаторов, такие как Bison и ANTLR. Например,
Postgres использует Bison~\cite{PostgresBisonGrammar}.

\subsection{Исполнение SQL запросов}

После преобразования запроса в абстрактное синтаксическое дерево, СУБД
транслирует его во внутреннее представление. Обычно, для этого используют
представления на основе расширенной реляционной алгебры. Дополнительно, на этом
этапе проверяется наличие таблиц и атрибутов, к которым обращается запрос.

Есть несколько вариантов, как исполнить один конкретный запрос: в каком порядке
применять фильтрацию и сортировку, когда делать проекцию? За нахождение
оптимального порядка отвечает оптимизатор. Он получает на вход запрос в форме
реляционной алгебры, а на выходе строит физический план выполнения.

Физический план принципиально отличается от запроса в формате реляционной
алгебры тем, что содержит все детали выполнения: конкретные алгоритмы исполнения
каждого этапа, используемые индексы и т.п.

Физический план является деревом, в котором данные перемещаются от листьев к
корню~\refImage{fig:query-plan}. Листья являются таблицами, а остальные вершины
--- операторами. Стрелочки показывают направление движения данных. Операторы
обычно являются одноместными или двуместными и соответствуют операторам
расширенной реляционной алгебры.

\begin{figure}[H]
  \centering
  \begin{minipage}[t]{\textwidth}
    \centering
    \includegraphics[width=0.5\textwidth]{query}
  \end{minipage}
  \caption{План запроса}\label{fig:query-plan}
\end{figure}

Существует три основные модели исполнения физических планов:

\begin{itemize}
  \item модель итераторов;
  \item материализационная модель;
  \item векторизированная модель.
\end{itemize}

\subsubsection{Модель итераторов}

Самая распространенная модель исполнения --- модель
итераторов~\cite{graefe2002volcano}. Каждый оператор является итератором ---
реализует функцию \verb|Next()|, которая возвращает следующий кортеж из
отношения. Простота данной идеи выгодно отличает ее от других вариантов и
позволяет легко комбинировать операторы, и, что важнее, свободно рассуждать о
них, потому что каждый оператор независим от другого.

В этой модели естественным образом получается конвейеризированное исполнение:
когда кортеж проходит все возможные операторы до чтения следующего. Операторы,
которые исполняются вместе, называют конвейером.

Некоторые операторы блокируют конвейверное исполнение. Например, для сортировки
требуется иметь в доступе все кортежи.

Также, в модели итераторов легко реализуется ограничение количества кортежей.
Это достигается путем прекращения вызовов \verb|Next()|, когда нужное количество
данных уже получено.

Минусом данной модели является большое количество накладных расходов на вызов
функций. Применение каждого оператора к каждому кортежу является вызовом функции
\verb|Next()|.

\subsubsection{Материализационная модель}

В материализационной модели каждый оператор обрабатывает все данные за один
вызов. Вместо \verb|Next()| реализуют функцию \verb|Output()|, которая в
качестве результата возвращается весь набор кортежей.

Зачастую, отношения настолько большие, что их нельзя держать целиком в памяти,
поэтому в результате каждой операции создается временная таблица на диске для
хранения промежуточных данных.

Эта модель подходит для баз данных для обработки транзакций, где запросы
затрагивают небольшое количество кортежей, но плохо работает в колоночных СУБД,
потому что там обрабатывается большое количество данных и постоянно приходится
сохранять промежуточные результаты на диск.

\subsubsection{Векторизированная модель}

Векторизованная модель схожа с моделью итераторов в том, что в ней обычно
реализуют функцию \verb|Next()|. Отличием является то, что эта функция
возвращает не один кортеж, а сразу массив из них.

Эта модель может показывать большую эффективность на современных процессорах,
потому что позволяет обрабатывать массивы данных без зависимости от управляющих
конструкций, таких как вызовы функций в итераторной модели.

\subsubsection{Порядок обработки}

Реализуют две модели:

\begin{itemize}
  \item сверху-вниз;
  \item снизу-вверх.
\end{itemize}

В модели сверху-вниз операторы запрашивают данные у своих потомков, что
предполагает вызовы функций. Здесь сложнее реализовать конкурентность в рамках
одного запроса, потому что оператор должен блокироваться на вызове
\verb|Next()|.

В модели снизу-вверх данные передаются от потомков к родителям. Эта модель
позволяет добиться прироста к производительности засчет более эффективного
использование кэша процессора в конвейерном исполнении запроса. Минусами можно
назвать более сложность ограничения количества обрабатываемых кортежей и
сложность реализации некоторых операторов в целом.

\subsubsection{Алгоритмы для реализации операторов реляционной алгебры}

Для доступа к данным на диске реализуют следующие основные алгоритмы:

\begin{itemize}
  \item последовательное сканирование;
  \item параллельное сканирование;
  \item сканирование с использованием индекса.
\end{itemize}

Последовательное сканирование итерируется по всем кортежам в одном потоке
исполнения.

Параллельное сканирование использует несколько потоков, которые читают
непересекающиеся блоки таблиц.

Сканирование с использованием индекса объединяет чтение таблицы и ее фильтрацию,
и использует для это индекс. Выбор подходящего индекса зависит от содержимого
таблицы и запроса, и может сильно ускорить чтение относительно последовательного
сканирования.

Операторы проекции и фильтрации реализуются очевидным образом и не ограничивают
конвейеризированное выполнение.

% TODO: sort, join, ... ?

Выражения в SQL используются в качестве условий для фильтрации, проекции,
определения операции соединения и т.д. Они представляются в виде дерева, где
узлами являются операции и значения:

\begin{enumerate}
  \item операции сравнения: \verb|=, <, >, !=|;
  \item логические операции: \verb|AND, OR и NOT|;
  \item арифметические операции: \verb|+, -, *, /, %|;
  \item константы;
  \item атрибуты отношений.
\end{enumerate}

Например, для выражения в запросе на листинге~\ref{lst:expression}, дерево
выглядит как на рисунке~\ref{fig:expression}.

\begin{listing}
  \caption{Пример запроса с выражением.}
  \label{lst:expression}
  \begin{minted}[style=bw, breaklines, frame=single, fontsize = \footnotesize, linenos=false, xleftmargin = 1.5em]{text}
SELECT * FROM users WHERE users.age > 33 + 1;
  \end{minted}
\end{listing}

\begin{figure}[H]
  \centering
  \begin{minipage}[t]{\textwidth}
    \centering
    \includegraphics[width=0.5\textwidth]{expression}
  \end{minipage}
  \caption{Дерево для вычисления выражения из примера на листинге~\ref{lst:expression}.}\label{fig:expression}
\end{figure}

Чтобы вычислить значение такого выражения, СУБД хранит информацию о текущем
кортеже и схемах используемых таблиц. Затем производится обход дерева с
выполнением операторов снизу-вверх. Результатом вычислений считается результат
вычисления оператора в корневой вершине.

Вычисление относительно сложных выражений происходит медленно, потому что каждый
оператор требует вызова функции, поэтому появляется множество вохможностей для
оптимазиции. Например:

\begin{itemize}
  \item JIT-компиляция;
  \item векторизация;
  \item сворачивание выражений с константами;
  \item дедупликация.
\end{itemize}

\subsection{JIT-компиляция}

JIT-компиляция означает динамическую генерацию машинного кода под текущую
аппаратную платформу во время исполнения запроса. Это позволяет значительно
упростить само выражение, применяя различные оптимизации, от сворачивания
констант, до исключения повторяющихся или невозможных частей. Особенная
эффективность данного подхода наблюдается в аналитических запросах, которые
работают с большими объемами данных и зачастую вычисляют запросы со сложными
условиями фильтрации, агрегации и большим количеством производных данных. Также
в числе возможных оптимизаций вычисление сдвигов для доступа к атрибутам внутри
кортежей.

Эту технику реализует большинство современных баз данных. Например, Postgres и
Clickhouse.

Основным преимуществом является возможность использования для оптимизаций
данных, доступных во время выполнения запроса, таких как схемы таблиц и типы
атрибутов. Недостатком можно считать большие затраты по времени на компиляцию,
которые делают JIT-компиляцию нецелесообразной для несложных или затрагивающих
небольшое количество кортежей запросов.

\section{Разработка СУБД}

В рамках данной работы была разработана модельная реляционная СУБД,
поддерживающая опциональную JIT-компиляцию выражений.

% 3. >=8 Конструкторский ("разработка ...."): обоснованный выбор алгоритма,
%    подробно его применение в данной задаче, проектирование архитектуры и
%    интерфейсов

\subsection{Парсер}

В качестве синтаксиса SQL было выбрано подмножество синтаксиса PostgreSQL, как
наиболее популярного на данный момент.

Из грамматики оставлены только \verb|SELECT| запросы, потому что в них зачастую
встречаются выражения и они представляют наибольший интерес для оптимизаций.
Также, именно запросы на чтение обычно автогенерируются системами визуализации
данных.

На вход парсер получает запрос в виде строки. На выходе в случае успешного
разбора получается синтаксическое дерево, а в случае ошибки или
неподдерживаемого запроса об этом сообщается пользователю.

Так как полная грамматика SQL очень большая, было решено воспользоваться одним
из генераторов синтаксических и лексических анализаторов и взять для него
готовое определение грамматики PostgreSQL.

\subsection{Преобразование запроса в релиционную алгебру}

После этапа лексического и синтаксического анализа, полученное дерево необходимо
преобразовать в представление в формате реляционной алгебры. Это достигается
засчет обхода дерева в глубину и возврата соответствущих операторов реляционной
алгебры вместо поддеревьев синтаксического дерева.

В результате получается дерево, состоящее из операторов реляционной алгебры и
отношений в качестве листьев. Для отладки было решено реализовать его
визуализацию.

Дальнейших преобразований запроса в формате реляционной алгебры предусмотрено не
было, так как это работа оптимизатора, что выходит за рамки работы и является
отдельной сложной темой.

\subsection{Исполнение запросов}

Далее, запрос в формате реляционной алгебры необходимо исполнить.

\subsection{Модуль хранения данных}

В целях простоты, а также ввиду реализации только запросов чтения, было решено
хранить данные в формате CSV (Comma-separated values) таблиц. Данный формат
легок в поддержке, и иделаьно подходит для реализации модельной СУБД в условиях
неизменяемости хранимых таблиц.

Каждая таблица хранится в отдельном CSV файле, который начинается с заголовка,
определяющего названия и типы атрибутов. В следующих строках содержатся кортежи.
Для простоты решено поддержать только два типа атрибутов: целочисленный и
логический. Пример отношения \verb|users|, состоящего из двух атрибутов:
\verb|id| и \verb|age|, можно увидеть на листинге~\ref{lst:users_relation}.

\begin{listing}
  \caption{Пример CSV файла, где хранится отношение users.}
  \label{lst:users_relation}
  \begin{minted}[style=bw, breaklines, frame=single, fontsize = \footnotesize, linenos=false, xleftmargin = 1.5em]{text}
id:int,age:int
1,33
2,64
3,22
4,NULL
5,15
  \end{minted}
\end{listing}

Для чтения данных из CSV файла применяется алгоритм последовательного
сканирования, ввиду удобства реализации и очевидной оценки сложности.

%    про исполнение запроса
%    про llvm
%

\end{document}
