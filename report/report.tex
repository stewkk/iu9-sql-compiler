% !TeX TXS-program:bibliography = txs:///biber
\documentclass[14pt, russian]{scrartcl}
\let\counterwithout\relax
\let\counterwithin\relax
%\usepackage{lmodern}
\usepackage{float}
\usepackage{xcolor}
\usepackage{extsizes}
\usepackage{subfig}
\usepackage[export]{adjustbox}
\usepackage{tocvsec2} % возможность менять учитываемую глубину разделов в оглавлении
\usepackage[subfigure]{tocloft}
\usepackage[newfloat]{minted}
\captionsetup[listing]{position=top}

\AtBeginEnvironment{figure}{\vspace{0.5cm}}
\AtBeginEnvironment{table}{\vspace{0.5cm}}
\AtBeginEnvironment{listing}{\vspace{0.5cm}}
\AtBeginEnvironment{algorithm}{\vspace{0.5cm}}
\AtBeginEnvironment{minted}{\vspace{-0.5cm}}

\usepackage{fancyvrb}
\usepackage{ulem,bm,mathrsfs,ifsym} %зачеркивания, особо жирный стиль и RSFS начертание
\usepackage{sectsty} % переопределение стилей подразделов
%%%%%%%%%%%%%%%%%%%%%%%

%%% Поля и разметка страницы %%%
\usepackage{pdflscape}                              % Для включения альбомных страниц
\usepackage{geometry}                               % Для последующего задания полей
\geometry{a4paper,tmargin=2cm,bmargin=2cm,lmargin=3cm,rmargin=1cm} % тоже самое, но лучше

%%% Математические пакеты %%%
\usepackage{amsthm,amsfonts,amsmath,amssymb,amscd}  % Математические дополнения от AMS
\usepackage{mathtools}                              % Добавляет окружение multlined
\usepackage[perpage]{footmisc}
%\usepackage{times}

\def\ojoin{\setbox0=\hbox{$\bowtie$}%
  \rule[-.02ex]{.25em}{.4pt}\llap{\rule[\ht0]{.25em}{.4pt}}}
\def\leftouterjoin{\mathbin{\ojoin\mkern-5.8mu\bowtie}}
\def\rightouterjoin{\mathbin{\bowtie\mkern-5.8mu\ojoin}}
\def\fullouterjoin{\mathbin{\ojoin\mkern-5.8mu\bowtie\mkern-5.8mu\ojoin}}

%%%% Установки для размера шрифта 14 pt %%%%
%% Формирование переменных и констант для сравнения (один раз для всех подключаемых файлов)%%
%% должно располагаться до вызова пакета fontspec или polyglossia, потому что они сбивают его работу
%\newlength{\curtextsize}
%\newlength{\bigtextsize}
%\setlength{\bigtextsize}{13pt}
\KOMAoptions{fontsize=14pt}

\makeatletter
\def\showfontsize{\f@size{} point}
\makeatother

%\makeatletter
%\show\f@size                                       % неплохо для отслеживания, но вызывает стопорение процесса, если документ компилируется без команды  -interaction=nonstopmode
%\setlength{\curtextsize}{\f@size pt}
%\makeatother

%шрифт times
\usepackage{tempora}
%\usepackage{pscyr}
%\setmainfont[Ligatures={TeX,Historic}]{Times New Roman}

   %%% Решение проблемы копирования текста в буфер кракозябрами
%    \input glyphtounicode.tex
%    \input glyphtounicode-cmr.tex %from pdfx package
%    \pdfgentounicode=1
    \usepackage{cmap}                               % Улучшенный поиск русских слов в полученном pdf-файле
    \usepackage[T1]{fontenc}                       % Поддержка русских букв
    \usepackage[utf8]{inputenc}                     % Кодировка utf8
    \usepackage[english, main=russian]{babel}            % Языки: русский, английский
%   \IfFileExists{pscyr.sty}{\usepackage{pscyr}}{}  % Красивые русские шрифты
%\renewcommand{\rmdefault}{ftm}
%%% Оформление абзацев %%%
\usepackage{indentfirst}                            % Красная строка
%\usepackage{eskdpz}

%%% Таблицы %%%
\usepackage{longtable}                              % Длинные таблицы
\usepackage{multirow,makecell,array}                % Улучшенное форматирование таблиц
\usepackage{booktabs}                               % Возможность оформления таблиц в классическом книжном стиле (при правильном использовании не противоречит ГОСТ)

%%% Общее форматирование
\usepackage{soulutf8}                               % Поддержка переносоустойчивых подчёркиваний и зачёркиваний
\usepackage{icomma}                                 % Запятая в десятичных дробях



%%% Изображения %%%
\usepackage{graphicx}                               % Подключаем пакет работы с графикой
\usepackage{wrapfig}

\usepackage{tikz}
\usetikzlibrary{shapes.misc}
\usetikzlibrary{trees}
\usetikzlibrary{arrows.meta}

%%% Списки %%%
\usepackage{enumitem}

%%% Подписи %%%
\usepackage{caption}                                % Для управления подписями (рисунков и таблиц) % Может управлять номерами рисунков и таблиц с caption %Иногда может управлять заголовками в списках рисунков и таблиц
%% Использование:
%\begin{table}[h!]\ContinuedFloat - чтобы не переключать счетчик
%\captionsetup{labelformat=continued}% должен стоять до самого caption
%\caption{}
% либо ручками \caption*{Продолжение таблицы~\ref{...}.} :)

%%% Интервалы %%%
\addto\captionsrussian{%
  \renewcommand{\listingname}{Листинг}%
}
%%% Счётчики %%%
\usepackage[figure,table,section]{totalcount}               % Счётчик рисунков и таблиц
\DeclareTotalCounter{lstlisting}
\usepackage{totcount}                               % Пакет создания счётчиков на основе последнего номера подсчитываемого элемента (может требовать дважды компилировать документ)
\usepackage{totpages}                               % Счётчик страниц, совместимый с hyperref (ссылается на номер последней страницы). Желательно ставить последним пакетом в преамбуле

%%% Продвинутое управление групповыми ссылками (пока только формулами) %%%
%% Кодировки и шрифты %%%

%   \newfontfamily{\cyrillicfont}{Times New Roman}
%   \newfontfamily{\cyrillicfonttt}{CMU Typewriter Text}
	%\setmainfont{Times New Roman}
	%\newfontfamily\cyrillicfont{Times New Roman}
	%\setsansfont{Times New Roman}                    %% задаёт шрифт без засечек
%	\setmonofont{Liberation Mono}               %% задаёт моноширинный шрифт
%    \IfFileExists{pscyr.sty}{\renewcommand{\rmdefault}{ftm}}{}
%%% Интервалы %%%
%linespread-реализация ближе к реализации полуторного интервала в ворде.
%setspace реализация заточена под шрифты 10, 11, 12pt, под остальные кегли хуже, но всё же ближе к типографской классике.
\linespread{1.3}                    % Полуторный интервал (ГОСТ Р 7.0.11-2011, 5.3.6)
%\renewcommand{\@biblabel}[1]{#1}

%%% Гиперссылки %%%
\usepackage{hyperref}

%%% Выравнивание и переносы %%%
\sloppy                             % Избавляемся от переполнений
\clubpenalty=10000                  % Запрещаем разрыв страницы после первой строки абзаца
\widowpenalty=10000                 % Запрещаем разрыв страницы после последней строки абзаца

\makeatletter % малые заглавные, small caps shape
\let\@@scshape=\scshape
\renewcommand{\scshape}{%
  \ifnum\strcmp{\f@series}{bx}=\z@
    \usefont{T1}{cmr}{bx}{sc}%
  \else
    \ifnum\strcmp{\f@shape}{it}=\z@
      \fontshape{scsl}\selectfont
    \else
      \@@scshape
    \fi
  \fi}
\makeatother

%%% Подписи %%%
%\captionsetup{%
%singlelinecheck=off,                % Многострочные подписи, например у таблиц
%skip=2pt,                           % Вертикальная отбивка между подписью и содержимым рисунка или таблицы определяется ключом
%justification=centering,            % Центрирование подписей, заданных командой \caption
%}
%%%        Подключение пакетов                 %%%
\usepackage{ifthen}                 % добавляет ifthenelse
%%% Инициализирование переменных, не трогать!  %%%
\newcounter{intvl}
\newcounter{otstup}
\newcounter{contnumeq}
\newcounter{contnumfig}
\newcounter{contnumtab}
\newcounter{pgnum}
\newcounter{bibliosel}
\newcounter{chapstyle}
\newcounter{headingdelim}
\newcounter{headingalign}
\newcounter{headingsize}
\newcounter{tabcap}
\newcounter{tablaba}
\newcounter{tabtita}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%% Область упрощённого управления оформлением %%%

%% Интервал между заголовками и между заголовком и текстом
% Заголовки отделяют от текста сверху и снизу тремя интервалами (ГОСТ Р 7.0.11-2011, 5.3.5)
\setcounter{intvl}{3}               % Коэффициент кратности к размеру шрифта

%% Отступы у заголовков в тексте
\setcounter{otstup}{0}              % 0 --- без отступа; 1 --- абзацный отступ

%% Нумерация формул, таблиц и рисунков
\setcounter{contnumeq}{1}           % Нумерация формул: 0 --- пораздельно (во введении подряд, без номера раздела); 1 --- сквозная нумерация по всей диссертации
\setcounter{contnumfig}{1}          % Нумерация рисунков: 0 --- пораздельно (во введении подряд, без номера раздела); 1 --- сквозная нумерация по всей диссертации
\setcounter{contnumtab}{1}          % Нумерация таблиц: 0 --- пораздельно (во введении подряд, без номера раздела); 1 --- сквозная нумерация по всей диссертации

%% Оглавление
\setcounter{pgnum}{0}               % 0 --- номера страниц никак не обозначены; 1 --- Стр. над номерами страниц (дважды компилировать после изменения)

%% Библиография
\setcounter{bibliosel}{1}           % 0 --- встроенная реализация с загрузкой файла через движок bibtex8; 1 --- реализация пакетом biblatex через движок biber

%% Текст и форматирование заголовков
\setcounter{chapstyle}{1}           % 0 --- разделы только под номером; 1 --- разделы с названием "Глава" перед номером
\setcounter{headingdelim}{1}        % 0 --- номер отделен пропуском в 1em или \quad; 1 --- номера разделов и приложений отделены точкой с пробелом, подразделы пропуском без точки; 2 --- номера разделов, подразделов и приложений отделены точкой с пробелом.

%% Выравнивание заголовков в тексте
\setcounter{headingalign}{0}        % 0 --- по центру; 1 --- по левому краю

%% Размеры заголовков в тексте
\setcounter{headingsize}{0}         % 0 --- по ГОСТ, все всегда 14 пт; 1 --- пропорционально изменяющийся размер в зависимости от базового шрифта

%% Подпись таблиц
\setcounter{tabcap}{0}              % 0 --- по ГОСТ, номер таблицы и название разделены тире, выровнены по левому краю, при необходимости на нескольких строках; 1 --- подпись таблицы не по ГОСТ, на двух и более строках, дальнейшие настройки:
%Выравнивание первой строки, с подписью и номером
\setcounter{tablaba}{2}             % 0 --- по левому краю; 1 --- по центру; 2 --- по правому краю
%Выравнивание строк с самим названием таблицы
\setcounter{tabtita}{1}             % 0 --- по левому краю; 1 --- по центру; 2 --- по правому краю

%%% Рисунки %%%
\DeclareCaptionLabelSeparator*{emdash}{~--- }             % (ГОСТ 2.105, 4.3.1)
\captionsetup[figure]{labelsep=emdash,font=onehalfspacing,position=bottom}

%%% Таблицы %%%
\ifthenelse{\equal{\thetabcap}{0}}{%
    \newcommand{\tabcapalign}{\raggedright}  % по левому краю страницы или аналога parbox
}

\ifthenelse{\equal{\thetablaba}{0} \AND \equal{\thetabcap}{1}}{%
    \newcommand{\tabcapalign}{\raggedright}  % по левому краю страницы или аналога parbox
}

\ifthenelse{\equal{\thetablaba}{1} \AND \equal{\thetabcap}{1}}{%
    \newcommand{\tabcapalign}{\centering}    % по центру страницы или аналога parbox
}

\ifthenelse{\equal{\thetablaba}{2} \AND \equal{\thetabcap}{1}}{%
    \newcommand{\tabcapalign}{\raggedleft}   % по правому краю страницы или аналога parbox
}

\ifthenelse{\equal{\thetabtita}{0} \AND \equal{\thetabcap}{1}}{%
    \newcommand{\tabtitalign}{\raggedright}  % по левому краю страницы или аналога parbox
}

\ifthenelse{\equal{\thetabtita}{1} \AND \equal{\thetabcap}{1}}{%
    \newcommand{\tabtitalign}{\centering}    % по центру страницы или аналога parbox
}

\ifthenelse{\equal{\thetabtita}{2} \AND \equal{\thetabcap}{1}}{%
    \newcommand{\tabtitalign}{\raggedleft}   % по правому краю страницы или аналога parbox
}

\DeclareCaptionFormat{tablenocaption}{\tabcapalign #1\strut}        % Наименование таблицы отсутствует
\ifthenelse{\equal{\thetabcap}{0}}{%
    \DeclareCaptionFormat{tablecaption}{\tabcapalign #1#2#3}
    \captionsetup[table]{labelsep=emdash}                       % тире как разделитель идентификатора с номером от наименования
}{%
    \DeclareCaptionFormat{tablecaption}{\tabcapalign #1#2\par%  % Идентификатор таблицы на отдельной строке
        \tabtitalign{#3}}                                       % Наименование таблицы строкой ниже
    \captionsetup[table]{labelsep=space}                        % пробельный разделитель идентификатора с номером от наименования
}
\captionsetup[table]{format=tablecaption,singlelinecheck=off,font=onehalfspacing,position=top,skip=-5pt}  % многострочные наименования и прочее
\DeclareCaptionLabelFormat{continued}{Продолжение таблицы~#2}
\setlength{\belowcaptionskip}{.2cm}
\setlength{\intextsep}{0ex}

%%% Подписи подрисунков %%%
\renewcommand{\thesubfigure}{\asbuk{subfigure}}           % Буквенные номера подрисунков
\captionsetup[subfigure]{font={normalsize},               % Шрифт подписи названий подрисунков (не отличается от основного)
    labelformat=brace,                                    % Формат обозначения подрисунка
    justification=centering,                              % Выключка подписей (форматирование), один из вариантов
}
%\DeclareCaptionFont{font12pt}{\fontsize{12pt}{13pt}\selectfont} % объявляем шрифт 12pt для использования в подписях, тут же надо интерлиньяж объявлять, если не наследуется
%\captionsetup[subfigure]{font={font12pt}}                 % Шрифт подписи названий подрисунков (всегда 12pt)

%%% Настройки гиперссылок %%%

\definecolor{linkcolor}{rgb}{0.0,0,0}
\definecolor{citecolor}{rgb}{0,0.0,0}
\definecolor{urlcolor}{rgb}{0,0,0}

\hypersetup{
    linktocpage=true,           % ссылки с номера страницы в оглавлении, списке таблиц и списке рисунков
%    linktoc=all,                % both the section and page part are links
%    pdfpagelabels=false,        % set PDF page labels (true|false)
    plainpages=true,           % Forces page anchors to be named by the Arabic form  of the page number, rather than the formatted form
    colorlinks,                 % ссылки отображаются раскрашенным текстом, а не раскрашенным прямоугольником, вокруг текста
    linkcolor={linkcolor},      % цвет ссылок типа ref, eqref и подобных
    citecolor={citecolor},      % цвет ссылок-цитат
    urlcolor={urlcolor},        % цвет гиперссылок
    pdflang={ru},
}
\urlstyle{same}
%%% Шаблон %%%
%\DeclareRobustCommand{\todo}{\textcolor{red}}       % решаем проблему превращения названия цвета в результате \MakeUppercase, http://tex.stackexchange.com/a/187930/79756 , \DeclareRobustCommand protects \todo from expanding inside \MakeUppercase
\setlength{\parindent}{2.5em}                       % Абзацный отступ. Должен быть одинаковым по всему тексту и равен пяти знакам (ГОСТ Р 7.0.11-2011, 5.3.7).

%%% Списки %%%
% Используем дефис для ненумерованных списков (ГОСТ 2.105-95, 4.1.7)
%\renewcommand{\labelitemi}{\normalfont\bfseries~{---}}
\renewcommand{\labelitemi}{\bfseries~{---}}
\setlist{nosep,%                                    % Единый стиль для всех списков (пакет enumitem), без дополнительных интервалов.
    labelindent=\parindent,leftmargin=*%            % Каждый пункт, подпункт и перечисление записывают с абзацного отступа (ГОСТ 2.105-95, 4.1.8)
}
%%%%%%%%%%%%%%%%%%%%%%
%\usepackage{xltxtra} % load xunicode

\usepackage{ragged2e}
\usepackage[explicit]{titlesec}
\usepackage{placeins}
\usepackage{xparse}
\usepackage{csquotes}

\usepackage{listingsutf8}
\usepackage{url} %пакеты расширений
\usepackage{algorithm, algorithmicx}
\usepackage[noend]{algpseudocode}
\usepackage{blkarray}
\usepackage{chngcntr}
\usepackage{tabularx}
\usepackage[backend=biber,
    bibstyle=gost-numeric,
    citestyle=nature]{biblatex}
\newcommand*\template[1]{\text{<}#1\text{>}}
\addbibresource{biblio.bib}

\titleformat{name=\section,numberless}[block]{\normalfont\Large\centering}{}{0em}{#1}
\titleformat{\section}[block]{\normalfont\Large\bfseries\raggedright}{}{0em}{\thesection\hspace{0.25em}#1}
\titleformat{\subsection}[block]{\normalfont\Large\bfseries\raggedright}{}{0em}{\thesubsection\hspace{0.25em}#1}
\titleformat{\subsubsection}[block]{\normalfont\large\bfseries\raggedright}{}{0em}{\thesubsubsection\hspace{0.25em}#1}

\let\Algorithm\algorithm
\renewcommand\algorithm[1][]{\Algorithm[#1]\setstretch{1.5}}
%\renewcommand{\listingscaption}{Листинг}

\usepackage{pifont}
\usepackage{calc}
\usepackage{suffix}
\usepackage{csquotes}
\DeclareQuoteStyle{russian}
    {\guillemotleft}{\guillemotright}[0.025em]
    {\quotedblbase}{\textquotedblleft}
\ExecuteQuoteOptions{style=russian}
\newcommand{\enq}[1]{\enquote{#1}}
\newcommand{\eng}[1]{\begin{english}#1\end{english}}
% Подчиненные счетчики в окружениях http://old.kpfu.ru/journals/izv_vuz/arch/sample1251.tex
\newcounter{cTheorem}
\newcounter{cDefinition}
\newcounter{cConsequent}
\newcounter{cExample}
\newcounter{cLemma}
\newcounter{cConjecture}
\newtheorem{Theorem}{Теорема}[cTheorem]
\newtheorem{Definition}{Определение}[cDefinition]
\newtheorem{Consequent}{Следствие}[cConsequent]
\newtheorem{Example}{Пример}[cExample]
\newtheorem{Lemma}{Лемма}[cLemma]
\newtheorem{Conjecture}{Гипотеза}[cConjecture]

\renewcommand{\theTheorem}{\arabic{Theorem}}
\renewcommand{\theDefinition}{\arabic{Definition}}
\renewcommand{\theConsequent}{\arabic{Consequent}}
\renewcommand{\theExample}{\arabic{Example}}
\renewcommand{\theLemma}{\arabic{Lemma}}
\renewcommand{\theConjecture}{\arabic{Conjecture}}
%\makeatletter
\NewDocumentCommand{\Newline}{}{\text{\\}}
\newcommand{\sequence}[2]{\ensuremath \left(#1,\ \dots,\ #2\right)}

\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}
\renewcommand{\listalgorithmname}{Список алгоритмов}
\floatname{algorithm}{Листинг}
\renewcommand{\lstlistingname}{Листинг}
\renewcommand{\thealgorithm}{\arabic{algorithm}}

\newcommand{\refAlgo}[1]{(листинг~\ref{#1})}
\newcommand{\refImage}[1]{(рисунок~\ref{#1})}

\renewcommand{\theenumi}{\arabic{enumi}.}% Меняем везде перечисления на цифра.цифра
\renewcommand{\labelenumi}{\arabic{enumi}.}% Меняем везде перечисления на цифра.цифра
\renewcommand{\theenumii}{\arabic{enumii}}% Меняем везде перечисления на цифра.цифра
\renewcommand{\labelenumii}{(\arabic{enumii})}% Меняем везде перечисления на цифра.цифра
\renewcommand{\theenumiii}{\roman{enumiii}}% Меняем везде перечисления на цифра.цифра
\renewcommand{\labelenumiii}{(\roman{enumiii})}% Меняем везде перечисления на цифра.цифра
%\newfontfamily\AnkaCoder[Path=src/fonts/]{AnkaCoder-r.ttf}
\renewcommand{\labelitemi}{---}
\renewcommand{\labelitemii}{---}

%\usepackage{courier}

\lstdefinelanguage{Refal}{
  alsodigit = {.,<,>},
  morekeywords = [1]{$ENTRY},
  morekeywords = [2]{Go, Put, Get, Open, Close, Arg, Add, Sub, Mul, Div, Symb, Explode, Implode},
  %keyword4
  morekeywords = [3]{<,>},
  %keyword5
  morekeywords = [4]{e.,t.,s.},
  sensitive = true,
  morecomment = [l]{*},
  morecomment = [s]{/*}{*/},
  commentstyle = \color{mygreen},
  morestring = [b]",
  morestring = [b]',
  stringstyle = \color{purple}
}

\makeatletter
\def\p@subsection{}
\def\p@subsubsection{\thesection\,\thesubsection\,}
\makeatother
\newcommand{\prog}[1]{{\ttfamily\small#1}}
\lstset{ %
  backgroundcolor=\color{white},   % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}
  basicstyle=\ttfamily\footnotesize,
  %basicstyle=\footnotesize\AnkaCoder,        % the size of the fonts that are used for the code
  breakatwhitespace=false,         % sets if automatic breaks shoulbd only happen at whitespace
  breaklines=true,                 % sets automatic line breaking
  captionpos=top,                    % sets the caption-position to bottom
  commentstyle=\color{mygreen},    % comment style
  deletekeywords={...},            % if you want to delete keywords from the given language
  escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
  extendedchars=true,              % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
  inputencoding=utf8,
  frame=single,                    % adds a frame around the code
  keepspaces=true,                 % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
  keywordstyle=\bf,       % keyword style
  language=Refal,                    % the language of the code
  morekeywords={<,>,$ENTRY,Go,Arg, Open, Close, e., s., t., Get, Put},
  							       % if you want to add more keywords to the set
  numbers=left,                    % where to put the line-numbers; possible values are (none, left, right)
  numbersep=5pt,                   % how far the line-numbers are from the code
  xleftmargin=25pt,
  xrightmargin=25pt,
  numberstyle=\small\color{black}, % the style that is used for the line-numbers
  rulecolor=\color{black},         % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
  showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
  showstringspaces=false,          % underline spaces within strings only
  showtabs=false,                  % show tabs within strings adding particular underscores
  stepnumber=1,                    % the step between two line-numbers. If it's 1, each line will be numbered
  stringstyle=\color{mymauve},     % string literal style
  tabsize=8,                       % sets default tabsize to 8 spaces
  title=\lstname                   % show the filename of files included with \lstinputlisting; also try caption instead of title
}
\newcommand{\anonsection}[1]{\cleardoublepage
\phantomsection
\addcontentsline{toc}{section}{\protect\numberline{}#1}
\section*{#1}\vspace*{2.5ex} % По госту положены 3 пустые строки после заголовка ненумеруемого раздела
}
\newcommand{\sectionbreak}{\clearpage}
\renewcommand{\sectionfont}{\normalsize} % Сбиваем стиль оглавления в стандартный
\renewcommand{\cftsecleader}{\cftdotfill{\cftdotsep}} % Точки в оглавлении напротив разделов

\renewcommand{\cftsecfont}{\normalfont\large} % Переключение на times в содержании
\renewcommand{\cftsubsecfont}{\normalfont\large} % Переключение на times в содержании

\usepackage{caption}
%\captionsetup[table]{justification=raggedleft}
%\captionsetup[figure]{justification=centering,labelsep=endash}
\usepackage{amsmath}    % \bar    (матрицы и проч. ...)
\usepackage{amsfonts}   % \mathbb (символ для множества действительных чисел и проч. ...)
\usepackage{mathtools}  % \abs, \norm
    \DeclarePairedDelimiter\abs{\lvert}{\rvert} % операция модуля
    \DeclarePairedDelimiter\norm{\lVert}{\rVert} % операция нормы
\DeclareTextCommandDefault{\textvisiblespace}{%
  \mbox{\kern.06em\vrule \@height.3ex}%
  \vbox{\hrule \@width.3em}%
  \hbox{\vrule \@height.3ex}}
\newsavebox{\spacebox}
\begin{lrbox}{\spacebox}
\verb*! !
\end{lrbox}
\newcommand{\aspace}{\usebox{\spacebox}}
\DeclareTotalCounter{listing}

\makeatletter
\renewcommand*{\p@subsubsection}{}
\makeatother

\makeatletter
\AddToHook{begindocument/before}{\@ifpackageloaded{minted}{\removefromtoclist[float]{lol}}{}}
\makeatother

\begin{document}
\sloppy

\def\figurename{Рисунок}

\begin{titlepage}
	\thispagestyle{empty}
	\newpage

	\vspace*{-30pt}
	\hspace{-45pt}
	\begin{minipage}{0.17\textwidth}
		\hspace*{-20pt}\centering
		\includegraphics[width=1.3\textwidth]{emblem.png}
	\end{minipage}
	\begin{minipage}{0.82\textwidth}\small \textbf{
			\vspace*{-0.7ex}
			\hspace*{-10pt}\centerline{Министерство науки и высшего образования Российской Федерации}
			\vspace*{-0.7ex}
			\centerline{Федеральное государственное автономное образовательное учреждение }
			\vspace*{-0.7ex}
			\centerline{высшего образования}
			\vspace*{-0.7ex}
			\centerline{<<Московский государственный технический университет}
			\vspace*{-0.7ex}
			\centerline{имени Н.Э. Баумана}
			\vspace*{-0.7ex}
			\centerline{(национальный исследовательский университет)>>}
			\vspace*{-0.7ex}
			\centerline{(МГТУ им. Н.Э. Баумана)}}
	\end{minipage}

	\vspace{-2pt}
	\hspace{-34.5pt}\rule{\textwidth}{2.5pt}

	\vspace*{-20.3pt}
	\hspace{-34.5pt}\rule{\textwidth}{0.4pt}

	\vspace{0.5ex}
	\noindent \small ФАКУЛЬТЕТ\hspace{80pt} <<Информатика и системы управления>>

	\vspace*{-16pt}
	\hspace{35pt}\rule{0.855\textwidth}{0.4pt}

	\vspace{0.5ex}
	\noindent \small КАФЕДРА\hspace{50pt} <<Теоретическая информатика и компьютерные технологии>>

	\vspace*{-16pt}
	\hspace{25pt}\rule{0.875\textwidth}{0.4pt}


	\vspace{3em}

	\begin{center}
		\Large \bf{РАСЧЕТНО-ПОЯСНИТЕЛЬНАЯ ЗАПИСКА\\\textbf{\textit{К КУРСОВОЙ РАБОТЕ\\НА ТЕМУ:}} \\}
	\end{center}

	\vspace*{-6ex}
	\begin{center}
		\Large{\textit{\textbf{<<Оптимизирующий компилятор запросов }}}

		\vspace*{-3ex}
		\rule{0.9\textwidth}{1.2pt}

		\vspace*{-0.2ex}
		\Large{\textit{\textbf{подмножества SQL на основе LLVM>>}}}

		\vspace*{-3ex}
		\vspace*{-0.2ex}
		\rule{0.9\textwidth}{1.2pt}

		\vspace*{-0.2ex}
		\rule{0.9\textwidth}{1.2pt}

		\vspace*{-0.2ex}
		\rule{0.9\textwidth}{1.2pt}

		\vspace*{-0.2ex}
		\rule{0.9\textwidth}{1.2pt}
	\end{center}

	\vspace{\fill}


	\newlength{\ML}
	\settowidth{\ML}{«\underline{\hspace{0.7cm}}» \underline{\hspace{2cm}}}

	\noindent Студент \underline{\text{ИУ9-71Б}} \hfill \underline{ \hspace{4cm}}\quad
	\raisebox{0.45ex}{\underline{\parbox{4cm}{\centering Старовойтов А.И.}}}

	\vspace{-2.1ex}
	\noindent\hspace{9ex}\scriptsize{(Группа)}\normalsize\hspace{170pt}\hspace{2ex}\scriptsize{(Подпись, дата)}\normalsize\hspace{30pt}\hspace{6ex}\scriptsize{(И.О. Фамилия)}\normalsize

	\bigskip

	\noindent Руководитель  \hfill \underline{\hspace{4cm}}\quad
	\raisebox{0.35ex}{\underline{\parbox{4cm}{\centering Непейвода А.Н.}}}

	\vspace{-2ex}
	\noindent\hspace{13.5ex}\normalsize\hspace{170pt}\hspace{2ex}\scriptsize{(Подпись, дата)}\normalsize\hspace{30pt}\hspace{6ex}\scriptsize{(И.О. Фамилия)}\normalsize

	\bigskip

	\noindent Консультант\hfill \underline{\hspace{4cm}}\quad
	\underline{\hspace{4cm}}

	\vspace{-2ex}
	\noindent\hspace{13.5ex}\normalsize\hspace{170pt}\hspace{2ex}\scriptsize{(Подпись, дата)}\normalsize\hspace{30pt}\hspace{6ex}\scriptsize{(И.О. Фамилия)}\normalsize
	\vfill

	%\vspace{\fill}



	\begin{center}
		\textsl{2026 г.}
	\end{center}
\end{titlepage}

%\renewcommand{\ttdefault}{pcr}

\setlength{\tabcolsep}{3pt}
\newpage
\setcounter{page}{2}
%----------------------------------------------------------------------------
%                  ОТСЮДА --- СОБСТВЕННО ТЕКСТ
%----------------------------------------------------------------------------

\newpage
\renewcommand\contentsname{\hfill{\normalfont{СОДЕРЖАНИЕ}}\hfill}  %Оглавление
\tableofcontents
\newpage
\anonsection{ВВЕДЕНИЕ}  %Введение

С развитием технологий обработки больших данных и появлением все большего числа
распределенных высоконагруженных систем, как никогда актуальным становится
вопрос эффективного хранения данных. Системы управления базами данных решают эти
задачи, упрощая разработку и экономя вычислительные ресурсы, а также место на
дисках.

Реляционные системы управления базами данных занимают более половины
рынка~\cite{DBReport} и остаются стандартом для хранения данных. Основным языком
запросов к таким системам является SQL.

Разработчики СУБД постоянно борются за производительность исполнения SQL
запросов, применяя различные техники, например: машинное обучение, аппаратное
ускорение, векторизированное исполнение и т.д. Одним из способов оптимизации,
позволяющим сэкономить ресурсы процессора при выполнении сложных запросов, может
быть JIT-компиляция некоторых частей запроса. Такая техника реализована в самых
популярных СУБД, таких как PostgreSQL~\cite{pantilimonov2019machine} и является
довольно актуальной для автоматически сгенерированных запросов, например в
системах визуализации данных в виде графиков и диаграмм, ввиду сложности
выражений для фильтрации и их неоптимальности.

Целью данной работы является реализация модельной реляционной СУБД с поддержкой
опциональной JIT-компиляции выражений в SELECT запросах на основе LLVM-JIT, а
также сравнение производительности исполнения с компиляцией и без.

\section{Обзор предметной области}

Обычно, СУБД верхнеуровнево разделяют на следующие
модули~\cite{silberschatz2020database}~\refImage{fig:dbms-scheme}:

\begin{itemize}
  \item модуль хранения данных;
  \item модуль обработки запросов;
  \item модуль управления транзакциями.
\end{itemize}

\begin{figure}[H]
  \centering
  \begin{minipage}[t]{\textwidth}
    \centering
    \includegraphics[width=\textwidth]{dbms_scheme}
  \end{minipage}
  \caption{Схема верхнеуровнего устройства СУБД.}\label{fig:dbms-scheme}
\end{figure}

\subsection{Модуль хранения данных}

Модуль хранения данных реализует удобный интерфейс для физического хранения
данных на диске, предоставляя возможность сохранять, читать и обновлять
информацию в базе данных.

Подсистемами модуля хранения данных являются:

\begin{itemize}
  \item система авторизации;
  \item система управления файлами;
  \item система страничной организации памяти.
\end{itemize}

Данные на диске хранятся в нескольких формах: файлы с даннми, хранилище
метаданных и индексы.

\subsection{Модуль обработки запросов}

Модуль обработки запросов отвечает за исполнение запросов пользователя. Его подсистемами являются:

\begin{itemize}
  \item парсер запросов в синтаксическое дерево;
  \item модуль преобразования синтаксического дерева в план исполнения запроса;
  \item оптимизатор планов исполнения запросов;
  \item модуль исполнения плана.
\end{itemize}

\subsection{Модуль управления транзакциями}

Задача этого модуля --- обеспечить атомарное выполнение нескольких запросов,
чтобы сохранить определенные инварианты относительно хранимых данных. Его подсистемами могут являться:

\begin{itemize}
  \item система восстановления после перезапуска;
  \item система синхронизации.
\end{itemize}

\subsection{Реляционная модель и реляционная алгебра}

Реляционная модель объединяет несколько концептов:

\begin{itemize}
  \item \emph{структура}: определения отношений и их содержимого не зависит от
        физического представления. Каждое отношение --- множество атрибутов,
        каждый атрибут имеет множество значений;
  \item \emph{целостность}: соблюдение определенных инвариантов относительно
        хранимых данных;
  \item \emph{интерфейс}: декларативный интерфейс для доступа и изменения данных
        при помощи отношений. Разработчик задает только желаемый результат, а
        СУБД определяет наиболее оптимальный способ его достижения.
\end{itemize}

Все это образует фреймворк для работы с данными, который не отличается от одной
СУБД к другой и избавляет от заботы о низкоуровневых деталях хранения.

\begin{Definition}[Отношение]
  Неупорядоченное множество, элементами которого являются кортежи из значений
  атрибутов, задающих сущности. Отношения иногда называют таблицами.
\end{Definition}

\begin{Definition}[Кортеж]
  Множество значений атрибутов в отношении. Значениями могут быть скаляры или
  более сложные структуры данных. Каждый атрибут, если не задано специальное
  ограничение, может принимать значение \verb|NULL|, означающее, что для данного
  кортежа значение данного атрибута не определено.
\end{Definition}

\begin{Definition}[Реляционная алгебра]
  Множество фундаментальных оперторов для получения и изменения кортежей в
  отношении. Каждый оператор принимает одно или несколько отношений в качестве
  входа и возвращает новое отношение в качестве выхода.
\end{Definition}

Чтобы представлить SQL запрос в терминах реляционной алгебры можно
скомбинировать соответствующие операторы. Перечислим основные:

\begin{itemize}
  \item $\sigma_{\text{predicate}}(R)$ --- позволяет фильтровать кортежи по
        предикату;
  \item $\pi_{A_{1}, \ldots, A\_{n}}(R)$ --- позволяет выбрать нужные атрибуты
        из кортежа;
  \item $\cap, \cup, -$ --- стандартные операции над множествами;
  \item $\times$ --- декартово произведение, соответствует \verb|INNER JOIN|;
  \item $\leftouterjoin, \rightouterjoin, \fullouterjoin$ --- реализуют
        \verb|OUTER JOIN|.
\end{itemize}

\subsection{Язык SQL}

С помощью языка запросов SQL, ``Structured Query Language'', происходит все
взаимодействие клиентов с СУБД: определение схем данных, изменение содержимого
таблиц и т.п. Этот язык появился в начале 1970-х и продолжает развиваться по сей
день. Язык разделяют на две части:

\begin{itemize}
  \item ``Data-definition language'' --- язык для определения схем таблиц;
  \item ``Data-manipulation language'' --- язык для получения и изменения данных в таблицах.
\end{itemize}

В этой работе мы фокусируемся на DML, а именно на части для получения данных,
где наиболее актуальна JIT-компиляция. Этот функционал реализован с помощью
ключевого слова ``SELECT''.

Грамматика ``SELECT''~\refAlgo{lst:select_grammar} позволяет задать:

\begin{itemize}
  \item ``FROM'' --- из каких таблиц брать данные;
  \item ``WHERE'' --- как их отфильтровать;
  \item ``GROUP BY'' --- какие функции агрегации использовать;
  \item ``ORDER BY'' --- порядок сортировки;
  \item ``LIMIT'' --- ограничение на количество кортежей;
  \item ``select\_list'' --- какие атрибуты возвращать.
\end{itemize}

\begin{listing}
  \caption{Грамматика ``SELECT''~\cite{PostgresDocs}.}
  \label{lst:select_grammar}
  \begin{minted}[style=bw, breaklines, frame=single, fontsize = \footnotesize, linenos=false, xleftmargin = 1.5em]{text}
SELECT [ DISTINCT | ALL ] select_list
    [ FROM table_expression ]
    [ WHERE condition ]
    [ GROUP BY grouping_element [, ...] ]
    [ HAVING condition ]
    [ WINDOW window_name AS ( window_definition ) [, ...] ]
    [ ORDER BY sort_expression [ ASC | DESC | USING operator ] [, ...] ]
    [ LIMIT { count | ALL } ]
    [ OFFSET start [ ROW | ROWS ] ]
    [ FETCH { FIRST | NEXT } [ count ] { ROW | ROWS } ONLY ]
    [ FOR { UPDATE | SHARE } [ OF table_name [, ...] ] [ NOWAIT | SKIP LOCKED ] [, ...] ] ;
  \end{minted}
\end{listing}

Пример ``SELECT'' запроса представлен в листинге~\ref{lst:select_example}.

\begin{listing}
  \caption{Пример SQL запроса.}
  \label{lst:select_example}
  \begin{minted}[style=bw, breaklines, frame=single, fontsize = \footnotesize, linenos=false, xleftmargin = 1.5em]{SQL}
SELECT name, phone FROM users WHERE age > 22;
  \end{minted}
\end{listing}

\subsection{Парсинг SQL запросов}

Парсер отвечает за преобразование SQL-запросов в абстрактное синтаксическое
дерево.

Помимо ANSI стандартов язка практически каждая СУБД реализует свой набор
расширений. Самым популярным из них считается синтаксис ``PostgreSQL''.

Синтаксис SQL довольно объемный, поэтому обычно используют генераторы
лексических и синтаксических анализаторов, такие как Bison и ANTLR. Например,
Postgres использует Bison~\cite{PostgresBisonGrammar}.

\subsection{Исполнение SQL запросов}

После преобразования запроса в абстрактное синтаксическое дерево, СУБД
транслирует его во внутреннее представление. Обычно, для этого используют
представления на основе расширенной реляционной алгебры. Дополнительно, на этом
этапе проверяется наличие таблиц и атрибутов, к которым обращается запрос.

Есть несколько вариантов, как исполнить один конкретный запрос: в каком порядке
применять фильтрацию и сортировку, когда делать проекцию? За нахождение
оптимального порядка отвечает оптимизатор. Он получает на вход запрос в форме
реляционной алгебры, а на выходе строит физический план выполнения.

Физический план принципиально отличается от запроса в формате реляционной
алгебры тем, что содержит все детали выполнения: конкретные алгоритмы исполнения
каждого этапа, используемые индексы и т.п.

Физический план является деревом, в котором данные перемещаются от листьев к
корню~\refImage{fig:query-plan}. Листья являются таблицами, а остальные вершины
--- операторами. Стрелочки показывают направление движения данных. Операторы
обычно являются одноместными или двуместными и соответствуют операторам
расширенной реляционной алгебры.

\begin{figure}[H]
  \centering
  \begin{minipage}[t]{\textwidth}
    \centering
    \includegraphics[width=0.5\textwidth]{query}
  \end{minipage}
  \caption{План запроса}\label{fig:query-plan}
\end{figure}

Существует три основные модели исполнения физических планов:

\begin{itemize}
  \item модель итераторов;
  \item материализационная модель;
  \item векторизированная модель.
\end{itemize}

\subsubsection{Модель итераторов}

Самая распространенная модель исполнения --- модель
итераторов~\cite{graefe2002volcano}. Каждый оператор является итератором ---
реализует функцию \verb|Next()|, которая возвращает следующий кортеж из
отношения. Простота данной идеи выгодно отличает ее от других вариантов и
позволяет легко комбинировать операторы, и, что важнее, свободно рассуждать о
них, потому что каждый оператор независим от другого.

В этой модели естественным образом получается конвейеризированное исполнение:
когда кортеж проходит все возможные операторы до чтения следующего. Операторы,
которые исполняются вместе, называют конвейером.

Некоторые операторы блокируют конвейверное исполнение. Например, для сортировки
требуется иметь в доступе все кортежи.

Также, в модели итераторов легко реализуется ограничение количества кортежей.
Это достигается путем прекращения вызовов \verb|Next()|, когда нужное количество
данных уже получено.

Минусом данной модели является большое количество накладных расходов на вызов
функций. Применение каждого оператора к каждому кортежу является вызовом функции
\verb|Next()|.

\subsubsection{Материализационная модель}

В материализационной модели каждый оператор обрабатывает все данные за один
вызов. Вместо \verb|Next()| реализуют функцию \verb|Output()|, которая в
качестве результата возвращается весь набор кортежей.

Зачастую, отношения настолько большие, что их нельзя держать целиком в памяти,
поэтому в результате каждой операции создается временная таблица на диске для
хранения промежуточных данных.

Эта модель подходит для баз данных для обработки транзакций, где запросы
затрагивают небольшое количество кортежей, но плохо работает в колоночных СУБД,
потому что там обрабатывается большое количество данных и постоянно приходится
сохранять промежуточные результаты на диск.

\subsubsection{Векторизированная модель}

Векторизованная модель схожа с моделью итераторов в том, что в ней обычно
реализуют функцию \verb|Next()|. Отличием является то, что эта функция
возвращает не один кортеж, а сразу массив из них.

Эта модель может показывать большую эффективность на современных процессорах,
потому что позволяет обрабатывать массивы данных без зависимости от управляющих
конструкций, таких как вызовы функций в итераторной модели.

\subsubsection{Порядок обработки}

Реализуют две модели:

\begin{itemize}
  \item сверху-вниз;
  \item снизу-вверх.
\end{itemize}

В модели сверху-вниз операторы запрашивают данные у своих потомков, что
предполагает вызовы функций. Здесь сложнее реализовать конкурентность в рамках
одного запроса, потому что оператор должен блокироваться на вызове
\verb|Next()|.

В модели снизу-вверх данные передаются от потомков к родителям. Эта модель
позволяет добиться прироста к производительности засчет более эффективного
использование кэша процессора в конвейерном исполнении запроса. Минусами можно
назвать более сложность ограничения количества обрабатываемых кортежей и
сложность реализации некоторых операторов в целом.

\subsubsection{Алгоритмы для реализации операторов реляционной алгебры}

Для доступа к данным на диске реализуют следующие основные алгоритмы:

\begin{itemize}
  \item последовательное сканирование;
  \item параллельное сканирование;
  \item сканирование с использованием индекса.
\end{itemize}

Последовательное сканирование итерируется по всем кортежам в одном потоке
исполнения.

Параллельное сканирование использует несколько потоков, которые читают
непересекающиеся блоки таблиц.

Сканирование с использованием индекса объединяет чтение таблицы и ее фильтрацию,
и использует для это индекс. Выбор подходящего индекса зависит от содержимого
таблицы и запроса, и может сильно ускорить чтение относительно последовательного
сканирования.

Операторы проекции и фильтрации реализуются очевидным образом и не ограничивают
конвейеризированное выполнение.

% TODO: sort, join, ... ?

Выражения в SQL используются в качестве условий для фильтрации, проекции,
определения операции соединения и т.д. Они представляются в виде дерева, где
узлами являются операции и значения:

\begin{enumerate}
  \item операции сравнения: \verb|=, <, >, !=|;
  \item логические операции: \verb|AND, OR и NOT|;
  \item арифметические операции: \verb|+, -, *, /, %|;
  \item константы;
  \item атрибуты отношений.
\end{enumerate}

Например, для выражения в запросе на листинге~\ref{lst:expression}, дерево
выглядит как на рисунке~\ref{fig:expression}.

\begin{listing}
  \caption{Пример запроса с выражением.}
  \label{lst:expression}
  \begin{minted}[style=bw, breaklines, frame=single, fontsize = \footnotesize, linenos=false, xleftmargin = 1.5em]{text}
SELECT * FROM users WHERE users.age > 33 + 1;
  \end{minted}
\end{listing}

\begin{figure}[H]
  \centering
  \begin{minipage}[t]{\textwidth}
    \centering
    \includegraphics[width=0.5\textwidth]{expression}
  \end{minipage}
  \caption{Дерево для вычисления выражения из примера на листинге~\ref{lst:expression}.}\label{fig:expression}
\end{figure}

Чтобы вычислить значение такого выражения, СУБД хранит информацию о текущем
кортеже и схемах используемых таблиц. Затем производится обход дерева с
выполнением операторов снизу-вверх. Результатом вычислений считается результат
вычисления оператора в корневой вершине.

Вычисление относительно сложных выражений происходит медленно, потому что каждый
оператор требует вызова функции, поэтому появляется множество вохможностей для
оптимазиции. Например:

\begin{itemize}
  \item JIT-компиляция;
  \item векторизация;
  \item сворачивание выражений с константами;
  \item дедупликация.
\end{itemize}

\subsection{JIT-компиляция}

JIT-компиляция означает динамическую генерацию машинного кода под текущую
аппаратную платформу во время исполнения запроса. Это позволяет значительно
упростить само выражение, применяя различные оптимизации, от сворачивания
констант, до исключения повторяющихся или невозможных частей. Особенная
эффективность данного подхода наблюдается в аналитических запросах, которые
работают с большими объемами данных и зачастую вычисляют запросы со сложными
условиями фильтрации, агрегации и большим количеством производных данных. Также
в числе возможных оптимизаций вычисление сдвигов для доступа к атрибутам внутри
кортежей.

Эту технику реализует большинство современных баз данных. Например, Postgres и
Clickhouse.

Основным преимуществом является возможность использования для оптимизаций
данных, доступных во время выполнения запроса, таких как схемы таблиц и типы
атрибутов. Недостатком можно считать большие затраты по времени на компиляцию,
которые делают JIT-компиляцию нецелесообразной для несложных или затрагивающих
небольшое количество кортежей запросов.

\section{Разработка модельной СУБД}

В рамках данной работы была разработана модельная реляционная СУБД,
поддерживающая опциональную JIT-компиляцию выражений.

% 3. >=8 Конструкторский ("разработка ...."): обоснованный выбор алгоритма,
%    подробно его применение в данной задаче, проектирование архитектуры и
%    интерфейсов

\subsection{Парсер}

В качестве синтаксиса SQL было выбрано подмножество синтаксиса PostgreSQL, как
наиболее популярного на данный момент.

Из грамматики оставлены только \verb|SELECT| запросы, потому что в них зачастую
встречаются выражения и они представляют наибольший интерес для оптимизаций.
Также, именно запросы на чтение обычно автогенерируются системами визуализации
данных. Сокращенная версию грамматики для \verb|SELECT| запросов находится в
листингах~\ref{lst:grammar1}~-~\ref{lst:grammar5}.

На вход парсер получает запрос в виде строки. На выходе в случае успешного
разбора получается синтаксическое дерево, а в случае ошибки или
неподдерживаемого запроса об этом сообщается пользователю.

Так как полная грамматика SQL очень большая, было решено воспользоваться одним
из генераторов синтаксических и лексических анализаторов и взять для него
готовое определение грамматики PostgreSQL.

\subsection{Преобразование запроса в релиционную алгебру}

После этапа лексического и синтаксического анализа, полученное дерево необходимо
преобразовать в представление в формате реляционной алгебры. Это достигается
засчет обхода дерева в глубину и возврата соответствущих операторов реляционной
алгебры вместо поддеревьев синтаксического дерева.

В результате получается дерево, состоящее из операторов реляционной алгебры и
отношений в качестве листьев. Для отладки было решено реализовать его
визуализацию.

Дальнейших преобразований запроса в формате реляционной алгебры предусмотрено не
было, так как это работа оптимизатора, что выходит за рамки работы и является
отдельной сложной темой.

\subsection{Исполнение запросов}

Далее, запрос необходимо исполнить. Для того, чтобы не увеличивать количество
внутренних представлений, запрос принято решение интерпретировать запрос
напрямую в форме реляционной алгебры.

Модель исполнения была выбрана векторизированная. Это сделано для того, чтобы не
органичивать возможности параллельного исполнения в рамках одного запроса и
использовать потенциал современных процессоров по-максимуму.

Порядок обработки был выбран снизу-вверх, а коммуникация между операторами
реализована с помощью потокобезопасных каналов, как в языке программирования Go.
Это упрощает рассуждения и уменьшает возможную площать для возникновения ошибок
в реализации.

Таким образом, каждый оператор создает по отдельному каналу для кортежей и типов
атрибутов своих потомков. Затем вызывает их в цикле читает из канала
кортежи~\refImage{fig:query_execution}. Такая схема легко реализуется и
предполагает одинаковый интерфейс у всех операторов, что позволяет с легкостью
их комбинировать.

\begin{figure}[H]
  \centering
  \begin{tikzpicture}[
    node distance=1.5cm,
    every node/.style={draw, rectangle, minimum width=2.5cm, minimum height=1cm, align=center},
    arrow style/.style={line width=1pt, double distance=3pt, arrows = {-Latex[length=0pt 3 0]}},
    label node/.style={draw=none, rectangle=none, minimum width=0, minimum height=0}
  ]
    \begin{scope}[xshift=-4cm]
      \node (users_left) at (0,0) {users};
      \node (groups_left) at (3.5,0) {groups};
      
      \node[minimum width=4.5cm, minimum height=1.5cm] (join_left) at (1.75,2.5) {$\leftouterjoin$\\ON users.group\_id = groups.id};
      
      \node[minimum width=4cm, minimum height=1.5cm] (filter_left) at (1.75,5.5) {$\sigma$\\users.age $>$ 18};
      
      \node[minimum width=4cm, minimum height=1.5cm] (proj_left) at (1.75,8.5) {$\pi$\\users.id, groups.id};
      
      \draw[arrow style] (users_left) -- node[label node, left, xshift=-0.5cm] {\scriptsize атрубуты} (join_left);
      \draw[arrow style] (groups_left) -- node[label node, right, xshift=0.5cm] {\scriptsize атрубуты} (join_left);
      \draw[arrow style] (join_left) -- node[label node, left, xshift=-0.5cm] {\scriptsize атрубуты} (filter_left);
      \draw[arrow style] (filter_left) -- node[label node, left, xshift=-0.5cm] {\scriptsize атрубуты} (proj_left);
      
      \node[label node] at (1.75,10.5) {\textbf{Этап 1}};
    \end{scope}
    
    \begin{scope}[xshift=4cm]
      \node (users_right) at (0,0) {users};
      \node (groups_right) at (3.5,0) {groups};
      
      \node[minimum width=4.5cm, minimum height=1.5cm] (join_right) at (1.75,2.5) {$\leftouterjoin$\\ON users.group\_id = groups.id};
      
      \node[minimum width=4cm, minimum height=1.5cm] (filter_right) at (1.75,5.5) {$\sigma$\\users.age $>$ 18};
      
      \node[minimum width=4cm, minimum height=1.5cm] (proj_right) at (1.75,8.5) {$\pi$\\users.id, groups.id};
      
      \draw[arrow style] (users_right) -- node[label node, left, xshift=-0.5cm] {\scriptsize кортежи} (join_right);
      \draw[arrow style] (groups_right) -- node[label node, right, xshift=0.5cm] {\scriptsize кортежи} (join_right);
      \draw[arrow style] (join_right) -- node[label node, left, xshift=-0.5cm] {\scriptsize кортежи} (filter_right);
      \draw[arrow style] (filter_right) -- node[label node, left, xshift=-0.5cm] {\scriptsize кортежи} (proj_right);
      
      \node[label node] at (1.75,10.5) {\textbf{Этап 2}};
    \end{scope}
  \end{tikzpicture}
  \caption{Двухэтапное исполнение запроса.}
\label{fig:query_execution}
\end{figure}

\subsection{Модуль хранения данных}

В целях простоты, а также ввиду реализации только запросов чтения, было решено
хранить данные в формате CSV (Comma-separated values) таблиц. Данный формат
легок в поддержке, и иделаьно подходит для реализации модельной СУБД в условиях
неизменяемости хранимых таблиц.

Каждая таблица хранится в отдельном CSV файле, который начинается с заголовка,
определяющего названия и типы атрибутов. В следующих строках содержатся кортежи.
Для простоты решено поддержать только два типа атрибутов: целочисленный и
логический. Пример отношения \verb|users|, состоящего из двух атрибутов:
\verb|id| и \verb|age|, можно увидеть на листинге~\ref{lst:users_relation}.

\begin{listing}[H]
  \caption{Пример CSV файла, где хранится отношение users.}
  \label{lst:users_relation}
  \begin{minted}[style=bw, breaklines, frame=single, fontsize = \footnotesize, linenos=false, xleftmargin = 1.5em]{text}
id:int,age:int
1,33
2,64
3,22
4,NULL
5,15
  \end{minted}
\end{listing}

Для чтения данных из CSV файла применяется алгоритм последовательного
сканирования, ввиду удобства реализации и очевидной оценки сложности.

\subsection{Алгоритмы для операторов реляционной алгебры}

Первый и простейший оператор, проекция, реализуется с помощью цикла, отражающего
каждый кортеж в новый с нужными атрибутами~\refAlgo{lst:projection}. Это
работает, т.к. $A_{1}, \ldots, A_{n}$ --- выражения, которые могут включать
атрибуты, константы и операции над ними, что позволяет добавлять значения,
производные от существующих.

\begin{listing}[H]
  \caption{Алгоритм выполнения проекции.}
  \label{lst:projection}
  \begin{algorithmic}[1]
    \Procedure{Projection}{$\pi_{A_1, \ldots, A_n}(R)$, $\text{out\_attr\_chan}$, $\text{out\_tuples\_chan}$}
      \State $(\text{attrs}, \text{tuples}) \gets \text{Compute}(R)$
      \State $\text{out\_attr\_chan} \gets \text{map}(\text{GetExpressionType}, [A_1, \ldots, A_n])$
      \For{$\text{tuple} \in \text{tuples}$}
        \For{$\text{expr} \in [A_1, \ldots, A_n]$}
          \State $\text{out\_tuples\_chan} \gets \text{CalcExpression}(\text{expr}, \text{tuple})$
        \EndFor
      \EndFor
    \EndProcedure
  \end{algorithmic}
\end{listing}

Следующий оператор, фильтрация, реализуется аналогично~\refAlgo{lst:filtration}. Включать ли в результат
текущий кортеж определяет значение выражения над ним.

\begin{listing}[H]
  \caption{Алгоритм выполнения фильтрации.}
  \label{lst:filtration}
  \begin{algorithmic}[1]
    \Procedure{Filter}{$\sigma_{\text{predicate}}(R)$, $\text{out\_attr\_chan}$, $\text{out\_tuples\_chan}$}
      \State $(\text{attrs}, \text{tuples}) \gets \text{Compute}(R)$
      \State $\text{out\_attr\_chan} \gets \text{attrs}$
      \For{$\text{tuple} \in \text{tuples}$}
        \If{$\text{CalcExpression}(\text{predicate}, \text{tuple}) = \text{true}$}
          \State $\text{out\_tuples\_chan} \gets \text{tuple}$
        \EndIf
      \EndFor
    \EndProcedure
  \end{algorithmic}
\end{listing}

Оператор соединения реализуется с помощью материализации одного из отношений на
диск и последующего многократного чтения и объединения с кортежами из второго
отношения~\refAlgo{lst:cross-join}.

\begin{listing}[H]
  \caption{Алгоритм выполнения декартова произведения.}
  \label{lst:cross-join}
  \begin{algorithmic}[1]
    \Procedure{CrossJoin}{$R_1 \times R_2$, $\text{out\_attr\_chan}$, $\text{out\_tuples\_chan}$}
      \State $\text{out\_attr\_chan} \gets \text{Concat}(\text{attrs}_1, \text{attrs}_2)$
      \State $\text{materialized}_1 \gets \text{Materialize}(\text{Compute}(R_1))$
      \State $(\text{attrs}_2, \text{tuples}_2) \gets \text{Compute}(R_2)$
      \For{$\text{tuple}_2 \in \text{tuples}_2$}
        \For{$\text{tuple}_1 \in \text{materialized}_1$}
          \State $\text{joined} \gets \text{ConcatTuples}(\text{tuple}_1, \text{tuple}_2)$
          \State $\text{out\_tuples\_chan} \gets \text{joined}$
        \EndFor
      \EndFor
    \EndProcedure
  \end{algorithmic}
\end{listing}

Алгоритмы для \verb|OUTER| соединений аналоичны реализации \verb|INNER JOIN|, но
добавляют фильтрацию после генерации соединенных кортежей.

Наибольший интерес представляет вычисление выражений, которое, как можно
заметить, используется в реализации операторов реляционной алгебры повсеместно.

В случае вычисления выражения путем прямой интерпретации, необходимо рекурсией
обойти дерево, которым это выражение представлено, и вычислить каждую операцию.
Каждая вершина такого дерева требует вызов функции, что для больших и сложных
выражений, умножить на количество кортежей в отношении, выливается в большие
накладные расходы на рекурсию~\refAlgo{lst:expression-interpretation}.

\begin{listing}[H]
  \caption{Алгоритм интерпретации выражения.}
  \label{lst:expression-interpretation}
  \begin{algorithmic}[1]
    \Function{CalcExpression}{$\text{expr}$, $\text{tuple}$, $\text{attrs}$}
      \If{$\text{expr}$ --- бинарная операция $(lhs, op, rhs)$}
        \State $\text{val}_1 \gets \textbf{\text{CalcExpression}}(lhs, \text{tuple}, \text{attrs})$
        \State $\text{val}_2 \gets \textbf{\text{CalcExpression}}(rhs, \text{tuple}, \text{attrs})$
        \State \Return $\text{ApplyOperator}(op, \text{val}_1, \text{val}_2)$
      \ElsIf{$\text{expr}$ --- унарная операция $(op, child)$}
        \State $\text{val} \gets \textbf{\text{CalcExpression}}(child, \text{tuple}, \text{attrs})$
        \State \Return $\text{ApplyUnaryOperator}(op, \text{val})$
      \ElsIf{$\text{expr}$ --- атрибут $A$}
        \State \Return $\text{Lookup}(A, \text{tuple}, \text{attrs})$
      \ElsIf{$\text{expr}$ --- константа $c$}
        \State \Return $c$
      \ElsIf{$\text{expr}$ --- литерал $l$}
        \State \Return $l$
      \EndIf
    \EndFunction
  \end{algorithmic}
\end{listing}

\subsection{JIT-компиляция}

Проблема высоких накладных расходов при рекурсивной интерпретации выражений
решается с помощью JIT-компиляции. Во время исполнения запроса, каждое выражение
перед исполнением компилируется в машинный код, что позволяет напрямую выполнить
набор инструкций для вычисления каждого выражения.

Скомпилированный код кэшируется в словарь, а затем переиспользуется для
вычисления каждого выражения.

В качестве фреймворка для JIT-компиляции был выбран LLVM, а в частности
современный интерфейс \verb|ORC v2|, ввиду наличия широкого набора
оптимизационных проходов, хорошей документации и понятного API для JIT.

Скомпилированный код представляет собой функцию, которая принимает на вход
указатель на результат, указатель на кортеж и указатель на информацию о типах и
названиях атрибутов. Результат вычисления выражения записывается по
соответствующему указателю.

Выражение вычисляется как комбинация операций эквивалентных исходному дереву.
Ветвления не используются в целях оптимизации.

Выбраны следующие оптимизационные проходы из доступных в LLVM, актуальные для
данной задачи:

\begin{itemize}
  \item \verb|EarlyCSEPass| --- раннее устранение общих подвыражений;
  \item \verb|SROAPass| --- скалярная замена агрегатов;
  \item \verb|InstCombinePass| --- комбинирование инструкций, включая сворачивание констант;
  \item \verb|SimplifyCFGPass| --- упрощение графа потока управления;
  \item \verb|ReassociatePass| --- переассоциация выражений;
  \item \verb|GVNPass| --- глобальная нумерация значений;
  \item \verb|MemCpyOptPass| --- оптимизация копирований памяти;
  \item \verb|SimplifyCFGPass| --- повторное упрощение графа потока управления;
  \item \verb|InstCombinePass| --- повторное комбинирование инструкций;
  \item \verb|ADCEPass| --- агрессивное удаление мёртвого кода.
\end{itemize}

\verb|EarlyCSEPass| --- легковесный проход, который исключает дублирующие
вычисления, путем обхода дерева доминаторов.

\verb|SROAPass| --- заменяет выделения памяти под структуры на скаляры, что
упрощает IR.

\verb|InstCombinePass| --- кобинирует инструкции, делая алгебраические
преобразования.

\verb|SimplifyCFGPass| --- убирает мертвый код.

\verb|ReassociatePass| --- меняет местами операнды и делает некоторые
алгебраические преобразования, чтобы позволить другим проходам сделать
дополнительные оптимизации.

\verb|GVNPass| --- убирает лишние, дублирующиеся, вычисления, где это возможно.

\verb|MemCpyOptPass| --- оптимизирует некоторые копирования и инициализации.

\verb|ADCEPass| --- удаляет мертвый код после всех других проходов.

Вместе все эти проходы делают все возможные оптимизации для ускорения вычисления
выражений.

\section{Реализация модельной СУБД}

Для выполнения поставленной задачи необходимо реализовать парсер, преобразование
в реляционную алгебру, выполнение соответствующих операторов и JIT-компиляцию
выражений, а также модульные тесты и бенчмарки производительности.

В качестве языка программирования использовался C++, ввиду следующих его
особенностей:

\begin{itemize}
  \item Высокая производительность. Современные СУБД обрабатывают огромные
        потоки данных от миллионов клиентов, поэтому важны минимальное
        потребление ресурсов и задержки.
  \item Возможность работать на низком уровне. Ручное управление памятью и
        прямая работа с системными вызовами открывает возможности для
        оптимизаций и позволяет сделать время обработки запросов предсказуемым.
  \item Поддержка ООП и RAII. Позволяет разрабатывать системный код читаемым и
        поддерживаемым.
  \item Широкий выбор библиотек для производительного сетевого взаимодействия и
        бинарной сериализации данных.
\end{itemize}

Все эти причины позволили C++ стать де-факто стандартным языком для реализации
СУБД.

Разработка проекта осуществлялась в редакторе кода Emacs. Данный редактор может
быть использван в качестве IDE благодаря обширной библиотеке плагинов.

Для сборки использовалось окружение NixOS. Этот дистрибутив Linux построен на
пакетном менеджере \verb|nix| и позволяет декларативно и воспроизводимо задавать
зависимости для каждого проекта, используя функциональный доменно-специфичный
язык.

В качестве системы сборки использован CMake, а компилятором выступает clang с
поддержкой стандарта C++23.

Для реализации конкурентной обработки запросов, были использованы C++20 корутины
в связке с boost::asio, так как это становится стандартным способом реализации
асинхронной модели в C++, и позволяет писать код, который выглядит линейно, но
исполняется конкурентно.

\subsection{Особенности реализации парсера}

Для реализации парсера был выбран ANTLR4, ввиду его удобства и возможности
генерировать лексические и синтаксические анализаторы под практически любой язык
программирования.

Грамматика PostgreSQL была взята из официального репозитория проекта
ANTLR4~\cite{Antlr4PostgreSQL}. Она была портирована автоматически из грамматики
для Bison~\cite{PostgresBisonGrammar} из официального репозитория Postgres,
поэтому является наиболее полной из существующих.

ANTLR4 генерирует несколько файлов на C++, в том числе лексический и
синтаксический анализаторы, а также класс \verb|Visitor| для обхода абстрактного
синтаксического дерева.

Основная функция определяющая интерфейс парсера представлена в
листинге~\ref{lst:getAst}. Она принимает поток, откуда читает запрос, а
возвращает \verb|Operator|~\refAlgo{lst:operator}, который является деревом из
операторов реляционной алгебры.

\begin{listing}[H]
  \caption{Интерфейс парсера.}
  \label{lst:getAst}
  \begin{minted}[style=bw, breaklines, frame=single, fontsize = \footnotesize, linenos=false, xleftmargin = 1.5em]{C++}
Result<Operator> GetAST(std::istream& in);
  \end{minted}
\end{listing}

\begin{listing}[H]
  \caption{Типы Operator, Table и Projection.}
  \label{lst:operator}
  \begin{minted}[style=bw, breaklines, frame=single, fontsize = \footnotesize, linenos=false, xleftmargin = 1.5em]{C++}
using Operator = std::variant<Table, Projection, Filter, CrossJoin, Join>;

struct Table {
    std::string name;
    auto operator<=>(const Table& other) const = default;
};

struct Projection {
    std::vector<Expression> expressions;
    std::shared_ptr<Operator> source;
    bool operator==(const Projection& other) const;
};
  \end{minted}
\end{listing}

Функция \verb|GetAST| внутри строит абстрактное синтаксическое дерево и обходит
его с помощью \verb|Visitor|, который и генерирует представление запроса в виде
дерева из \verb|Operator|.

Дополнительно реализована визуализация дерева из операторов реляционной алгебры
в формате Graphviz с помощью функции \verb|GetDotRepresentation|.

\subsection{Особенности реализации хранения данных}

Данные хранятся в одной директории, где каждому отношению соответствует файл с
CSV таблицей. Название файла совпадает с названием отношения.

Для чтения таблиц реализован класс \verb|CsvDirSequentialScanner|~\refAlgo{lst:csv-dir-seq-scanner}.

\begin{listing}[H]
  \caption{Объявление класса CsvDirSequentialScanner.}
  \label{lst:csv-dir-seq-scanner}
  \begin{minted}[style=bw, breaklines, frame=single, fontsize = \footnotesize, linenos=false, xleftmargin = 1.5em]{C++}
struct CsvDirSequentialScanner {
    std::string dir;

    boost::asio::awaitable<Result<>> operator()(const std::string& table_name,
                                                AttributesInfoChannel& attrs_chan,
                                                TuplesChannel& tuples_chan) const;
};
  \end{minted}
\end{listing}

\subsection{Особенности реализации исполнения запроса}

За исполнение запросов отвечает класс \verb|Executor|~\refAlgo{lst:executor}. Он
реализует исполнение всего дерева операторов, и каждого оператора отдельно, с
помощью функций \verb|Execute|.

\begin{listing}[H]
  \caption{Объявление класса Executor.}
  \label{lst:executor}
  \begin{minted}[style=bw, breaklines, frame=single, fontsize = \footnotesize, linenos=false, xleftmargin = 1.5em]{C++}
template <typename ExpressionExecutor = InterpretedExpressionExecutor>
class Executor {
public:
  using SequentialScan = std::function<boost::asio::awaitable<Result<>>(
      const std::string& table_name, AttributesInfoChannel& attr_chan, TuplesChannel& tuples_chan)>;
  Executor(SequentialScan seq_scan, boost::asio::any_io_executor executor);
  boost::asio::awaitable<Result<Relation>> Execute(const Operator& op);
private:
  boost::asio::awaitable<void> Execute(const Operator& op, AttributesInfoChannel& attr_chan,
                                       TuplesChannel& tuples_chan);
  boost::asio::awaitable<void> ExecuteProjection(const Projection& proj, AttributesInfoChannel& attr_chan,
                                                 TuplesChannel& tuples_chan);
...
  boost::asio::awaitable<void> SpawnExecutor(const Operator& op, AttributesInfoChannel& attr_chan, TuplesChannel& tuple_chan);
private:
  SequentialScan sequential_scan_;
  ExpressionExecutor expression_executor_;
};
  \end{minted}
\end{listing}

Этот класс параметризуется интерфейсами \verb|SequentialScan| и
\verb|ExpressionExecutor|.

Первый служит для того, чтобы выбирать различные реализации чтения таблиц с
диска.

\verb|ExpressionExecutor| является шаблонным параметром и нужен для выбора
реализации исполнения выражений. Реализовано три таких класса:

\begin{itemize}
  \item \verb|InterpretedExpressionExecutor| --- реализует обыкновенную
        интерпретацию выражений с помощью рекурсии;
  \item \verb|JitCompiledExpressionExecutor| --- реализует JIT-компиляцию
        выражения;
  \item
        \verb|CachedJitCompiledExpressionExecutor|~\refAlgo{lst:cached-jit-executor}
        --- кэширует результаты JIT-компиляции для переиспользования.
\end{itemize}

\begin{listing}[H]
  \caption{Объявление класса CachedJitCompiledExpressionExecutor.}
  \label{lst:cached-jit-executor}
  \begin{minted}[style=bw, breaklines, frame=single, fontsize = \footnotesize, linenos=false, xleftmargin = 1.5em]{C++}
using ExecExpression = std::function<Value(const Tuple& source, const AttributesInfo& source_attrs)>;
class CachedJitCompiledExpressionExecutor {
  public:
    explicit CachedJitCompiledExpressionExecutor(boost::asio::any_io_executor executor);
    boost::asio::awaitable<ExecExpression> GetExpressionExecutor(const Expression& expr, const AttributesInfo& attrs);
  private:
    JITCompiler compiler_;
    std::unordered_map<std::string, ExecExpression> cache_;
};
  \end{minted}
\end{listing}

Значения внутри выражений передаются в виде объектов класса
\verb|Value|~\refAlgo{lst:value}. Этот класс состоит из флага \verb|is_null|,
означающего определено ли данное значение и объекта \verb|NonNullValue|, где
\verb|NonNullValue| --- объединение \verb|int64_t| и \verb|bool|.

\begin{listing}[H]
  \caption{Объявление класса Value.}
  \label{lst:value}
  \begin{minted}[style=bw, breaklines, frame=single, fontsize = \footnotesize, linenos=false, xleftmargin = 1.5em]{C++}
union NonNullValue {
    int64_t int_value;
    bool bool_value;
};

struct Value {
    bool is_null;
    NonNullValue value;

    bool operator==(const Value& other) const;
};
  \end{minted}
\end{listing}

Отношения представлены в виде списка атрибутов и списка кортежей. Атрибуты
представлены в виде структуры с полями: имя таблицы, название атрибута и тип
атрибута. Кортеж --- вектор объектов класса \verb|Value|.

Коммуникация между операторами осуществляется при помощи класса
\verb|boost::asio::concurrent_channel|. Он предоставляет интерфейс, схожий с
каналами в языке Go. Его особенности:

\begin{itemize}
  \item потокобезопасность;
  \item буферизированность;
  \item асинхронность при использовании \verb|async_read| и \verb|async_write|;
  \item совместимость с корутинами.
\end{itemize}

В модельной СУБД используется два типа каналов: \verb|TuplesChannel| для
передачи кортежей и \verb|AttributesChannel| для передачи атрибутов отношений~\refAlgo{lst:channels}.

\begin{listing}[H]
  \caption{Объявление алиасов для каналов.}
  \label{lst:channels}
  \begin{minted}[style=bw, breaklines, frame=single, fontsize = \footnotesize, linenos=false, xleftmargin = 1.5em]{C++}
using TuplesChannel = boost::asio::experimental::concurrent_channel<
void(boost::system::error_code, Tuples)>;
using AttributesInfoChannel = boost::asio::experimental::concurrent_channel<
void(boost::system::error_code, AttributesInfo)>;
  \end{minted}
\end{listing}

\subsection{Особенности реализации JIT-компиляции}

JIT-компиляция происходит в классе
\verb|JITCompiler|~\refAlgo{lst:jit_compiler}. Метод \verb|CompileExpression|
принимает поддерево в реляционной алгебре и список доступных атрибутов, а
возвращает \verb|CompiledExpression| --- указатель на скомпилированную функцию,
которую можно по нему вызвать.

\begin{listing}[H]
  \caption{Объявление класса JITCompiler.}
  \label{lst:jit_compiler}
  \begin{minted}[style=bw, breaklines, frame=single, fontsize = \footnotesize, linenos=false, xleftmargin = 1.5em]{C++}
class JITCompiler {
    public:
        using CompiledExpression = void (*)(Value*, const Value*, const AttributeInfo*);
        explicit JITCompiler(boost::asio::any_io_executor executor);
        boost::asio::awaitable<std::pair<CompiledExpression, llvm::orc::ResourceTrackerSP>>
        CompileExpression(const Expression& expr, const AttributesInfo& attrs);
    private:
      llvm::Function* GenerateIR(llvm::Module& llvm_module, const Expression& expr,
                                 const AttributesInfo& attrs);
    private:
        std::unique_ptr<llvm::orc::LLJIT> jit_;
        std::atomic<uint64_t> id_;
        boost::asio::strand<boost::asio::any_io_executor> jit_strand_;
};
  \end{minted}
\end{listing}

В конструкторе~\refAlgo{lst:jit_compiler_constructor} производится настройка
оптимизирующих проходов и остальной инфраструктуры llvm.

На примере класса \verb|GenerateIRVisitor|~\refAlgo{lst:ir_generator} можно
увидеть, как производится генерация LLVM IR. Здесь нет ветвлений и вызовов
функций, что позволяет генерировать оптимальный код, и делать это быстро.
Результат генерации после оптимизации для выражения на листинге~\ref{lst:expression_for_ir} можно увидеть на
листинге~\ref{lst:ir_example}.

\begin{listing}[H]
  \caption{Пример выражения.}
  \label{lst:expression_for_ir}
  \begin{minted}[style=bw, breaklines, frame=single, fontsize = \footnotesize, linenos=false, xleftmargin = 1.5em]{text}
users.age > 30 AND users.age < 60 OR users.age = 10;
  \end{minted}
\end{listing}

\begin{listing}[H]
  \caption{LLVM IR для примера на листинге~\ref{lst:expression_for_ir}.}
  \label{lst:ir_example}
  \begin{minted}[style=bw, breaklines, frame=single, fontsize = \footnotesize, linenos=false, xleftmargin = 1.5em]{text}
; ModuleID = 'expr_module_0'
source_filename = "expr_module_0"
target datalayout = "e-m:e-p270:32:32-p271:32\
:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"

%Value = type { i8, i64 }

define void @eval_expr_1(ptr noalias %0, ptr %1, ptr %2) {
entry:
  %struct_ptr = getelementptr inbounds nuw i8, ptr %1, i64 16
  %loaded_struct = load %Value, ptr %struct_ptr, align 8
  %value.is_null = extractvalue %Value %loaded_struct, 0
  %is_null = icmp ne i8 %value.is_null, 0
  %value.value = extractvalue %Value %loaded_struct, 1
  %is_null_i8 = zext i1 %is_null to i8
  %result.with_is_null = insertvalue %Value undef, i8 %is_null_i8, 0
  %3 = add i64 %value.value, -31
  %4 = icmp ult i64 %3, 29
  %5 = icmp eq i64 %value.value, 10
  %6 = or i1 %5, %4
  %i1_to_i64_zext38 = zext i1 %6 to i64
  %result41 = insertvalue %Value %result.with_is_null, i64 %i1_to_i64_zext38, 1
  store %Value %result41, ptr %0, align 8
  ret void
}
  \end{minted}
\end{listing}

\section{Тестирование}

Тестирование разработанной модельной СУБД осуществлялось с помощью модульных
тестов. Также для замеров производительности были реализованы бенчмарки.

\subsection{Модульные тесты}

Модульные тесты реализованы с использованием библиотеки googletests и проверяют
корректность реализации основных классов в парсере и исполнителе выражений.

Пример такого теста приведен в листинге~\ref{lst:googletest}.

\begin{listing}[H]
  \caption{Пример модульного теста.}
  \label{lst:googletest}
  \begin{minted}[style=bw, breaklines, frame=single, fontsize = \footnotesize, linenos=false, xleftmargin = 1.5em]{cpp}
TEST(ParserTest, SelectSingleColumnFromSingleTable) {
  std::stringstream s{"SELECT users.id FROM users;"};

  Operator got = GetAST(s).value();

  ASSERT_THAT(got, VariantWith<Projection>(
      Projection{std::vector<Expression>{
      {Attribute{"users", "id"}}},
      std::make_shared<Operator>(Table{"users"})}));
}
  \end{minted}
\end{listing}

\subsection{Бенчмарки}

Тесты производительности реализованы с помощью библиотеки google benchmarks. Они
служат для измерения производительности \verb|SELECT| запросов с JIT-компиляцией
и без в различных профилях нагрузки и с различными настройками. Пример такого
бенчмарка можно увидеть в листинге~\ref{lst:bench}.

\begin{listing}[H]
  \caption{Пример бенчмарка.}
  \label{lst:bench}
  \begin{minted}[style=bw, breaklines, frame=single, fontsize = \footnotesize, linenos=false, xleftmargin = 1.5em]{cpp}
template <typename ExprExecutor, const char* Query>
void BM_SQL(benchmark::State& state) {
  std::ofstream nullstream("/dev/null");
  std::clog.rdbuf(nullstream.rdbuf());
  boost::asio::io_context ctx;
  boost::asio::co_spawn(
      ctx,
      [&state]() -> boost::asio::awaitable<void> {
        std::stringstream s{Query};
        Operator op = GetAST(s).value();
        CsvDirSequentialScanner seq_scan{kProjectDir + "/test/static/executor/test_data"};
        Executor<ExprExecutor> executor(
          std::move(seq_scan),
          co_await boost::asio::this_coro::executor
        );
        benchmark::DoNotOptimize(co_await executor.Execute(op));
        for (auto _ : state) {
          benchmark::DoNotOptimize(co_await executor.Execute(op));
        }
      }(),
      [](std::exception_ptr p) {});
  ctx.run();
}
  \end{minted}
\end{listing}

При дебаге проблем с производительностью также было удобно пользоваться утилитой
\verb|perf|, с помощью которой были построены и проанализированы ``флеймграфы''.

Далее, с помощью \verb|Python| и библиотеки \verb|pandas| были проанализированы
результаты выполнения бенчмарков~\refImage{fig:perf}. На рисунке по оси абсцисс
изображен условный размер используемых отображений в количестве кортежей. Как
можно увидеть на рисунке~\ref{fig:speedup}, на среднем количестве кортежей, где
не так сильно влияет время на чтение и запись на диск, получается около $40\%$
прироста к производительности.

\newpage
\anonsection{ЗАКЛЮЧЕНИЕ}  %Заключение

В ходе выполнения курсовой работы была разработана модельная реляционная СУБД с
поддержкой опциональной JIT-компиляции выражений, реализация проверена с помощью
модульных тестов, а также проведены измерения производительности.

Цель курсовой работы была достигнута. Получена стабильная система,
демонстрирующая возможности JIT-компиляции для оптимизации запросов на чтение.

В заключение, несмотря на достигнутые положительные результаты, существует
потенциал для дальнейшего улучшения реализации модельной СУБД. Это включает в
себя поддержку большего объема синтаксиса языка SQL, а также реализация более
продвинутых вариаций алгоритмов для основных операций реляционной алгебры.

\newpage
\renewcommand\refname{СПИСОК ИСПОЛЬЗОВАННЫХ ИСТОЧНИКОВ}
% Список литературы
\clearpage
\phantomsection
\addcontentsline{toc}{section}{\protect\numberline{}\refname}
%\bibliographystyle{ugost2008s}  %utf8gost71u.bst} %utf8gost705u} %gost2008s}
{\catcode`"\active\def"{\relax}
% \bibliography{biblio2}
\printbibliography
}
\newpage
\settocdepth{section}
\anonsection{ПРИЛОЖЕНИЕ А}
\vspace{-30pt}

\begin{listing}[H]
  \caption{Реализация конструктора класса JITCompiler.}
  \label{lst:jit_compiler_constructor}
  \inputminted[style=bw, breaklines, frame=single, fontsize = \footnotesize, linenos=false, xleftmargin = 1.5em]{cpp}{./listings/jit_compiler_constructor.cpp}
\end{listing}

\begin{listing}[H]
  \caption{Класс GenerateIRVisitor}
  \label{lst:ir_generator}
  \inputminted[style=bw, breaklines, frame=single, fontsize = \footnotesize, linenos=false, xleftmargin = 1.5em]{cpp}{./listings/ir_generator.cpp}
\end{listing}

\begin{figure}[H]
  \centering
  \begin{minipage}[t]{\textwidth}
    \centering
    \includegraphics[width=\textwidth]{perf}
  \end{minipage}
  \caption{Результаты бенчмарков.}\label{fig:perf}
\end{figure}

\begin{figure}[H]
  \centering
  \begin{minipage}[t]{\textwidth}
    \centering
    \includegraphics[width=\textwidth]{speedup}
  \end{minipage}
  \caption{Относительный прирост производительности.}\label{fig:speedup}
\end{figure}

\begin{listing}[H]
  \caption{Грамматика для SELECT (часть 1).}
  \label{lst:grammar1}
  \inputminted[style=bw, breaklines, frame=single, fontsize = \footnotesize, linenos=false, xleftmargin = 1.5em]{cpp}{./listings/grammar1.g4}
\end{listing}

\begin{listing}[H]
  \caption{Грамматика для SELECT (часть 2).}
  \label{lst:grammar2}
  \inputminted[style=bw, breaklines, frame=single, fontsize = \footnotesize, linenos=false, xleftmargin = 1.5em]{cpp}{./listings/grammar2.g4}
\end{listing}

\begin{listing}[H]
  \caption{Грамматика для SELECT (часть 3).}
  \label{lst:grammar3}
  \inputminted[style=bw, breaklines, frame=single, fontsize = \footnotesize, linenos=false, xleftmargin = 1.5em]{cpp}{./listings/grammar3.g4}
\end{listing}

\begin{listing}[H]
  \caption{Грамматика для SELECT (часть 4).}
  \label{lst:grammar4}
  \inputminted[style=bw, breaklines, frame=single, fontsize = \footnotesize, linenos=false, xleftmargin = 1.5em]{cpp}{./listings/grammar4.g4}
\end{listing}

\begin{listing}[H]
  \caption{Грамматика для SELECT (часть 5).}
  \label{lst:grammar5}
  \inputminted[style=bw, breaklines, frame=single, fontsize = \footnotesize, linenos=false, xleftmargin = 1.5em]{cpp}{./listings/grammar5.g4}
\end{listing}

\end{document}
